{
  "version": 3,
  "sources": ["../../@langchain/core/dist/prompts/base.js", "../../@langchain/core/dist/prompts/string.js", "../../@langchain/core/dist/prompts/template.js", "../../@langchain/core/dist/prompts/prompt.js"],
  "sourcesContent": ["// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { Runnable } from \"../runnables/base.js\";\n/**\n * Base class for prompt templates. Exposes a format method that returns a\n * string prompt given a set of input values.\n */\nexport class BasePromptTemplate extends Runnable {\n    get lc_attributes() {\n        return {\n            partialVariables: undefined, // python doesn't support this yet\n        };\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", this._getPromptType()]\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"partialVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { inputVariables } = input;\n        if (inputVariables.includes(\"stop\")) {\n            throw new Error(\"Cannot have an input variable named 'stop', as it is used internally, please rename.\");\n        }\n        Object.assign(this, input);\n    }\n    /**\n     * Merges partial variables and user variables.\n     * @param userVariables The user variables to merge with the partial variables.\n     * @returns A Promise that resolves to an object containing the merged variables.\n     */\n    async mergePartialAndUserVariables(userVariables) {\n        const partialVariables = this.partialVariables ?? {};\n        const partialValues = {};\n        for (const [key, value] of Object.entries(partialVariables)) {\n            if (typeof value === \"string\") {\n                partialValues[key] = value;\n            }\n            else {\n                partialValues[key] = await value();\n            }\n        }\n        const allKwargs = {\n            ...partialValues,\n            ...userVariables,\n        };\n        return allKwargs;\n    }\n    /**\n     * Invokes the prompt template with the given input and options.\n     * @param input The input to invoke the prompt template with.\n     * @param options Optional configuration for the callback.\n     * @returns A Promise that resolves to the output of the prompt template.\n     */\n    async invoke(input, options) {\n        return this._callWithConfig((input) => this.formatPromptValue(input), input, { ...options, runType: \"prompt\" });\n    }\n    /**\n     * Return a json-like object representing this prompt template.\n     * @deprecated\n     */\n    serialize() {\n        throw new Error(\"Use .toJSON() instead\");\n    }\n    /**\n     * @deprecated\n     * Load a prompt template from a json-like object describing it.\n     *\n     * @remarks\n     * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can\n     * reference remote resources that we read asynchronously with a web\n     * request.\n     */\n    static async deserialize(data) {\n        switch (data._type) {\n            case \"prompt\": {\n                const { PromptTemplate } = await import(\"./prompt.js\");\n                return PromptTemplate.deserialize(data);\n            }\n            case undefined: {\n                const { PromptTemplate } = await import(\"./prompt.js\");\n                return PromptTemplate.deserialize({ ...data, _type: \"prompt\" });\n            }\n            case \"few_shot\": {\n                const { FewShotPromptTemplate } = await import(\"./few_shot.js\");\n                return FewShotPromptTemplate.deserialize(data);\n            }\n            default:\n                throw new Error(`Invalid prompt type in config: ${data._type}`);\n        }\n    }\n}\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { StringPromptValue, } from \"../prompt_values.js\";\nimport { BasePromptTemplate } from \"./base.js\";\n/**\n * Base class for string prompt templates. It extends the\n * BasePromptTemplate class and overrides the formatPromptValue method to\n * return a StringPromptValue.\n */\nexport class BaseStringPromptTemplate extends BasePromptTemplate {\n    /**\n     * Formats the prompt given the input values and returns a formatted\n     * prompt value.\n     * @param values The input values to format the prompt.\n     * @returns A Promise that resolves to a formatted prompt value.\n     */\n    async formatPromptValue(values) {\n        const formattedPrompt = await this.format(values);\n        return new StringPromptValue(formattedPrompt);\n    }\n}\n", "export const parseFString = (template) => {\n    // Core logic replicated from internals of pythons built in Formatter class.\n    // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n    const chars = template.split(\"\");\n    const nodes = [];\n    const nextBracket = (bracket, start) => {\n        for (let i = start; i < chars.length; i += 1) {\n            if (bracket.includes(chars[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    let i = 0;\n    while (i < chars.length) {\n        if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n            nodes.push({ type: \"literal\", text: \"{\" });\n            i += 2;\n        }\n        else if (chars[i] === \"}\" &&\n            i + 1 < chars.length &&\n            chars[i + 1] === \"}\") {\n            nodes.push({ type: \"literal\", text: \"}\" });\n            i += 2;\n        }\n        else if (chars[i] === \"{\") {\n            const j = nextBracket(\"}\", i);\n            if (j < 0) {\n                throw new Error(\"Unclosed '{' in template.\");\n            }\n            nodes.push({\n                type: \"variable\",\n                name: chars.slice(i + 1, j).join(\"\"),\n            });\n            i = j + 1;\n        }\n        else if (chars[i] === \"}\") {\n            throw new Error(\"Single '}' in template.\");\n        }\n        else {\n            const next = nextBracket(\"{}\", i);\n            const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n            nodes.push({ type: \"literal\", text });\n            i = next < 0 ? chars.length : next;\n        }\n    }\n    return nodes;\n};\nexport const interpolateFString = (template, values) => parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n        if (node.name in values) {\n            return res + values[node.name];\n        }\n        throw new Error(`Missing value for input ${node.name}`);\n    }\n    return res + node.text;\n}, \"\");\nexport const DEFAULT_FORMATTER_MAPPING = {\n    \"f-string\": interpolateFString,\n};\nexport const DEFAULT_PARSER_MAPPING = {\n    \"f-string\": parseFString,\n};\nexport const renderTemplate = (template, templateFormat, inputValues) => DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\nexport const parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nexport const checkValidTemplate = (template, templateFormat, inputVariables) => {\n    if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n        throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n    }\n    try {\n        const dummyInputs = inputVariables.reduce((acc, v) => {\n            acc[v] = \"foo\";\n            return acc;\n        }, {});\n        if (Array.isArray(template)) {\n            template.forEach((message) => {\n                if (message.type === \"text\") {\n                    renderTemplate(message.text, templateFormat, dummyInputs);\n                }\n                else if (message.type === \"image_url\") {\n                    if (typeof message.image_url === \"string\") {\n                        renderTemplate(message.image_url, templateFormat, dummyInputs);\n                    }\n                    else {\n                        const imageUrl = message.image_url.url;\n                        renderTemplate(imageUrl, templateFormat, dummyInputs);\n                    }\n                }\n                else {\n                    throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);\n                }\n            });\n        }\n        else {\n            renderTemplate(template, templateFormat, dummyInputs);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        throw new Error(`Invalid prompt schema: ${e.message}`);\n    }\n};\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate, } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n    static lc_name() {\n        return \"PromptTemplate\";\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.assign(this, input);\n        if (this.validateTemplate) {\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"prompt\";\n    }\n    /**\n     * Formats the prompt template with the provided values.\n     * @param values The values to be used to format the prompt template.\n     * @returns A promise that resolves to a string which is the formatted prompt.\n     */\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        return renderTemplate(this.template, this.templateFormat, allValues);\n    }\n    /**\n     * Take examples in list format with prefix and suffix to create a prompt.\n     *\n     * Intended to be used a a way to dynamically create a prompt from examples.\n     *\n     * @param examples - List of examples to use in the prompt.\n     * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n     * @param inputVariables - A list of variable names the final prompt template will expect\n     * @param exampleSeparator - The separator to use in between examples\n     * @param prefix - String that should go before any examples. Generally includes examples.\n     *\n     * @returns The final prompt template generated.\n     */\n    static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n        const template = [prefix, ...examples, suffix].join(exampleSeparator);\n        return new PromptTemplate({\n            inputVariables,\n            template,\n        });\n    }\n    /**\n     * Load prompt template from a template f-string\n     */\n    static fromTemplate(template, { templateFormat = \"f-string\", ...rest } = {}) {\n        const names = new Set();\n        parseTemplate(template, templateFormat).forEach((node) => {\n            if (node.type === \"variable\") {\n                names.add(node.name);\n            }\n        });\n        return new PromptTemplate({\n            // Rely on extracted types\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            inputVariables: [...names],\n            templateFormat,\n            template,\n            ...rest,\n        });\n    }\n    /**\n     * Partially applies values to the prompt template.\n     * @param values The values to be partially applied to the prompt template.\n     * @returns A new instance of PromptTemplate with the partially applied values.\n     */\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new PromptTemplate(promptDict);\n    }\n    serialize() {\n        if (this.outputParser !== undefined) {\n            throw new Error(\"Cannot serialize a prompt template with an output parser\");\n        }\n        return {\n            _type: this._getPromptType(),\n            input_variables: this.inputVariables,\n            template: this.template,\n            template_format: this.templateFormat,\n        };\n    }\n    static async deserialize(data) {\n        if (!data.template) {\n            throw new Error(\"Prompt template must have a template\");\n        }\n        const res = new PromptTemplate({\n            inputVariables: data.input_variables,\n            template: data.template,\n            templateFormat: data.template_format,\n        });\n        return res;\n    }\n}\n"],
  "mappings": "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",
  "names": ["input", "PromptTemplate", "i"]
}
