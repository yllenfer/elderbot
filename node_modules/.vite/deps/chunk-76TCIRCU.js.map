{
  "version": 3,
  "sources": ["../../@langchain/core/dist/output_parsers/base.js", "../../@langchain/core/dist/outputs.js", "../../@langchain/core/dist/utils/@cfworker/json-schema/src/deep-compare-strict.js", "../../@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.js", "../../@langchain/core/dist/utils/@cfworker/json-schema/src/format.js", "../../@langchain/core/dist/output_parsers/transform.js", "../../@langchain/core/dist/output_parsers/bytes.js", "../../@langchain/core/dist/output_parsers/list.js", "../../@langchain/core/dist/output_parsers/string.js", "../../@langchain/core/dist/output_parsers/json.js", "../../@langchain/core/dist/utils/sax-js/sax.js", "../../@langchain/core/dist/output_parsers/xml.js"],
  "sourcesContent": ["import { Runnable } from \"../runnables/index.js\";\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport class BaseLLMOutputParser extends Runnable {\n    /**\n     * Parses the result of an LLM call with a given prompt. By default, it\n     * simply calls `parseResult`.\n     * @param generations The generations from an LLM call.\n     * @param _prompt The prompt used in the LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parseResultWithPrompt(generations, _prompt, callbacks) {\n        return this.parseResult(generations, callbacks);\n    }\n    /**\n     * Calls the parser with a given input and optional configuration options.\n     * If the input is a string, it creates a generation with the input as\n     * text and calls `parseResult`. If the input is a `BaseMessage`, it\n     * creates a generation with the input as a message and the content of the\n     * input as text, and then calls `parseResult`.\n     * @param input The input to the parser, which can be a string or a `BaseMessage`.\n     * @param options Optional configuration options.\n     * @returns A promise of the parsed output.\n     */\n    async invoke(input, options) {\n        if (typeof input === \"string\") {\n            return this._callWithConfig(async (input) => this.parseResult([{ text: input }]), input, { ...options, runType: \"parser\" });\n        }\n        else {\n            return this._callWithConfig(async (input) => this.parseResult([\n                {\n                    message: input,\n                    text: typeof input.content === \"string\"\n                        ? input.content\n                        : JSON.stringify(input.content),\n                },\n            ]), input, { ...options, runType: \"parser\" });\n        }\n    }\n}\n/**\n * Class to parse the output of an LLM call.\n */\nexport class BaseOutputParser extends BaseLLMOutputParser {\n    parseResult(generations, callbacks) {\n        return this.parse(generations[0].text, callbacks);\n    }\n    async parseWithPrompt(text, _prompt, callbacks) {\n        return this.parse(text, callbacks);\n    }\n    /**\n     * Return the string type key uniquely identifying this class of parser\n     */\n    _type() {\n        throw new Error(\"_type not implemented\");\n    }\n}\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nexport class OutputParserException extends Error {\n    constructor(message, llmOutput, observation, sendToLLM = false) {\n        super(message);\n        Object.defineProperty(this, \"llmOutput\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sendToLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llmOutput = llmOutput;\n        this.observation = observation;\n        this.sendToLLM = sendToLLM;\n        if (sendToLLM) {\n            if (observation === undefined || llmOutput === undefined) {\n                throw new Error(\"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\");\n            }\n        }\n    }\n}\n", "export const RUN_KEY = \"__run\";\n/**\n * Chunk of a single generation. Used for streaming.\n */\nexport class GenerationChunk {\n    constructor(fields) {\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"generationInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.text = fields.text;\n        this.generationInfo = fields.generationInfo;\n    }\n    concat(chunk) {\n        return new GenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n        });\n    }\n}\nexport class ChatGenerationChunk extends GenerationChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"message\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.message = fields.message;\n    }\n    concat(chunk) {\n        return new ChatGenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n            message: this.message.concat(chunk.message),\n        });\n    }\n}\n", "export function deepCompareStrict(a, b) {\n    const typeofa = typeof a;\n    if (typeofa !== typeof b) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b)) {\n            return false;\n        }\n        const length = a.length;\n        if (length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < length; i++) {\n            if (!deepCompareStrict(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeofa === \"object\") {\n        if (!a || !b) {\n            return a === b;\n        }\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        const length = aKeys.length;\n        if (length !== bKeys.length) {\n            return false;\n        }\n        for (const k of aKeys) {\n            if (!deepCompareStrict(a[k], b[k])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b;\n}\n", "import { encodePointer } from \"./pointer.js\";\nexport const schemaKeyword = {\n    additionalItems: true,\n    unevaluatedItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    unevaluatedProperties: true,\n    propertyNames: true,\n    not: true,\n    if: true,\n    then: true,\n    else: true,\n};\nexport const schemaArrayKeyword = {\n    prefixItems: true,\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true,\n};\nexport const schemaMapKeyword = {\n    $defs: true,\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    dependentSchemas: true,\n};\nexport const ignoredKeyword = {\n    id: true,\n    $id: true,\n    $ref: true,\n    $schema: true,\n    $anchor: true,\n    $vocabulary: true,\n    $comment: true,\n    default: true,\n    enum: true,\n    const: true,\n    required: true,\n    type: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    multipleOf: true,\n    maxLength: true,\n    minLength: true,\n    pattern: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    uniqueItems: true,\n    maxProperties: true,\n    minProperties: true,\n};\n/**\n * Default base URI for schemas without an $id.\n * https://json-schema.org/draft/2019-09/json-schema-core.html#initial-base\n * https://tools.ietf.org/html/rfc3986#section-5.1\n */\nexport let initialBaseURI = \n// @ts-ignore\ntypeof self !== \"undefined\" &&\n    self.location &&\n    self.location.origin !== \"null\"\n    ? //@ts-ignore\n        /* #__PURE__ */ new URL(self.location.origin + self.location.pathname + location.search)\n    : /* #__PURE__ */ new URL(\"https://github.com/cfworker\");\nexport function dereference(schema, lookup = Object.create(null), baseURI = initialBaseURI, basePointer = \"\") {\n    if (schema && typeof schema === \"object\" && !Array.isArray(schema)) {\n        const id = schema.$id || schema.id;\n        if (id) {\n            const url = new URL(id, baseURI.href);\n            if (url.hash.length > 1) {\n                lookup[url.href] = schema;\n            }\n            else {\n                url.hash = \"\"; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n                if (basePointer === \"\") {\n                    baseURI = url;\n                }\n                else {\n                    dereference(schema, lookup, baseURI);\n                }\n            }\n        }\n    }\n    else if (schema !== true && schema !== false) {\n        return lookup;\n    }\n    // compute the schema's URI and add it to the mapping.\n    const schemaURI = baseURI.href + (basePointer ? \"#\" + basePointer : \"\");\n    if (lookup[schemaURI] !== undefined) {\n        throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n    }\n    lookup[schemaURI] = schema;\n    // exit early if this is a boolean schema.\n    if (schema === true || schema === false) {\n        return lookup;\n    }\n    // set the schema's absolute URI.\n    if (schema.__absolute_uri__ === undefined) {\n        Object.defineProperty(schema, \"__absolute_uri__\", {\n            enumerable: false,\n            value: schemaURI,\n        });\n    }\n    // if a $ref is found, resolve it's absolute URI.\n    if (schema.$ref && schema.__absolute_ref__ === undefined) {\n        const url = new URL(schema.$ref, baseURI.href);\n        url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n        Object.defineProperty(schema, \"__absolute_ref__\", {\n            enumerable: false,\n            value: url.href,\n        });\n    }\n    // if a $recursiveRef is found, resolve it's absolute URI.\n    if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {\n        const url = new URL(schema.$recursiveRef, baseURI.href);\n        url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n        Object.defineProperty(schema, \"__absolute_recursive_ref__\", {\n            enumerable: false,\n            value: url.href,\n        });\n    }\n    // if an $anchor is found, compute it's URI and add it to the mapping.\n    if (schema.$anchor) {\n        const url = new URL(\"#\" + schema.$anchor, baseURI.href);\n        lookup[url.href] = schema;\n    }\n    // process subschemas.\n    for (let key in schema) {\n        if (ignoredKeyword[key]) {\n            continue;\n        }\n        const keyBase = `${basePointer}/${encodePointer(key)}`;\n        const subSchema = schema[key];\n        if (Array.isArray(subSchema)) {\n            if (schemaArrayKeyword[key]) {\n                const length = subSchema.length;\n                for (let i = 0; i < length; i++) {\n                    dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n                }\n            }\n        }\n        else if (schemaMapKeyword[key]) {\n            for (let subKey in subSchema) {\n                dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);\n            }\n        }\n        else {\n            dereference(subSchema, lookup, baseURI, keyBase);\n        }\n    }\n    return lookup;\n}\n// schema identification examples\n// https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.appendix.A\n// $ref delegation\n// https://github.com/json-schema-org/json-schema-spec/issues/514\n// output format\n// https://json-schema.org/draft/2019-09/json-schema-core.html#output\n// JSON pointer\n// https://tools.ietf.org/html/rfc6901\n// JSON relative pointer\n// https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01\n", "// based on https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\n// const URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nconst URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// For the source: https://gist.github.com/dperini/729294\n// For test cases: https://mathiasbynens.be/demo/url-regex\nconst URL_ = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\nconst UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\nconst JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\nconst RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n// date: http://tools.ietf.org/html/rfc3339#section-5.6\nconst FASTDATE = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/;\n// date-time: http://tools.ietf.org/html/rfc3339#section-5.6\nconst FASTTIME = /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst FASTDATETIME = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i;\n// uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n// const FASTURI = /^(?:[a-z][a-z0-9+-.]*:)(?:\\/?\\/)?[^\\s]*$/i;\nconst FASTURIREFERENCE = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i;\n// https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\nconst EMAIL = (input) => {\n    if (input[0] === '\"')\n        return false;\n    const [name, host, ...rest] = input.split(\"@\");\n    if (!name ||\n        !host ||\n        rest.length !== 0 ||\n        name.length > 64 ||\n        host.length > 253)\n        return false;\n    if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\"))\n        return false;\n    if (!/^[a-z0-9.-]+$/i.test(host) ||\n        !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))\n        return false;\n    return host\n        .split(\".\")\n        .every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));\n};\n// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\nconst IPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\n// optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\nconst IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\n// https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\nconst DURATION = (input) => input.length > 1 &&\n    input.length < 80 &&\n    (/^P\\d+([.,]\\d+)?W$/.test(input) ||\n        (/^P[\\dYMDTHS]*(\\d[.,]\\d+)?[YMDHS]$/.test(input) &&\n            /^P([.,\\d]+Y)?([.,\\d]+M)?([.,\\d]+D)?(T([.,\\d]+H)?([.,\\d]+M)?([.,\\d]+S)?)?$/.test(input)));\nfunction bind(r) {\n    return r.test.bind(r);\n}\nexport const fullFormat = {\n    date,\n    time: /* #__PURE__ */ time.bind(undefined, false),\n    \"date-time\": date_time,\n    duration: DURATION,\n    uri,\n    \"uri-reference\": /* #__PURE__ */ bind(URIREF),\n    \"uri-template\": /* #__PURE__ */ bind(URITEMPLATE),\n    url: /* #__PURE__ */ bind(URL_),\n    email: EMAIL,\n    hostname: /* #__PURE__ */ bind(HOSTNAME),\n    ipv4: /* #__PURE__ */ bind(IPV4),\n    ipv6: /* #__PURE__ */ bind(IPV6),\n    regex: regex,\n    uuid: /* #__PURE__ */ bind(UUID),\n    \"json-pointer\": /* #__PURE__ */ bind(JSON_POINTER),\n    \"json-pointer-uri-fragment\": /* #__PURE__ */ bind(JSON_POINTER_URI_FRAGMENT),\n    \"relative-json-pointer\": /* #__PURE__ */ bind(RELATIVE_JSON_POINTER),\n};\nexport const fastFormat = {\n    ...fullFormat,\n    date: /* #__PURE__ */ bind(FASTDATE),\n    time: /* #__PURE__ */ bind(FASTTIME),\n    \"date-time\": /* #__PURE__ */ bind(FASTDATETIME),\n    \"uri-reference\": /* #__PURE__ */ bind(FASTURIREFERENCE),\n};\nfunction isLeapYear(year) {\n    // https://tools.ietf.org/html/rfc3339#appendix-C\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nfunction date(str) {\n    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n    const matches = str.match(DATE);\n    if (!matches)\n        return false;\n    const year = +matches[1];\n    const month = +matches[2];\n    const day = +matches[3];\n    return (month >= 1 &&\n        month <= 12 &&\n        day >= 1 &&\n        day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]));\n}\nfunction time(full, str) {\n    const matches = str.match(TIME);\n    if (!matches)\n        return false;\n    const hour = +matches[1];\n    const minute = +matches[2];\n    const second = +matches[3];\n    const timeZone = !!matches[5];\n    return (((hour <= 23 && minute <= 59 && second <= 59) ||\n        (hour == 23 && minute == 59 && second == 60)) &&\n        (!full || timeZone));\n}\nconst DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n    // http://tools.ietf.org/html/rfc3339#section-5.6\n    const dateTime = str.split(DATE_TIME_SEPARATOR);\n    return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);\n}\nconst NOT_URI_FRAGMENT = /\\/|:/;\nconst URI_PATTERN = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nfunction uri(str) {\n    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n    return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);\n}\nconst Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n    if (Z_ANCHOR.test(str))\n        return false;\n    try {\n        new RegExp(str);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n", "import { BaseOutputParser } from \"./base.js\";\nimport { isBaseMessage, isBaseMessageChunk, } from \"../messages/index.js\";\nimport { GenerationChunk, ChatGenerationChunk, } from \"../outputs.js\";\nimport { deepCompareStrict } from \"../utils/@cfworker/json-schema/index.js\";\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport class BaseTransformOutputParser extends BaseOutputParser {\n    async *_transform(inputGenerator) {\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk === \"string\") {\n                yield this.parseResult([{ text: chunk }]);\n            }\n            else {\n                yield this.parseResult([\n                    {\n                        message: chunk,\n                        text: typeof chunk.content === \"string\"\n                            ? chunk.content\n                            : JSON.stringify(chunk.content),\n                    },\n                ]);\n            }\n        }\n    }\n    /**\n     * Transforms an asynchronous generator of input into an asynchronous\n     * generator of parsed output.\n     * @param inputGenerator An asynchronous generator of input.\n     * @param options A configuration object.\n     * @returns An asynchronous generator of parsed output.\n     */\n    async *transform(inputGenerator, options) {\n        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n            ...options,\n            runType: \"parser\",\n        });\n    }\n}\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport class BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"diff\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.diff = fields?.diff ?? this.diff;\n    }\n    async *_transform(inputGenerator) {\n        let prevParsed;\n        let accGen;\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n                throw new Error(\"Cannot handle non-string output.\");\n            }\n            let chunkGen;\n            if (isBaseMessageChunk(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new ChatGenerationChunk({\n                    message: chunk,\n                    text: chunk.content,\n                });\n            }\n            else if (isBaseMessage(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new ChatGenerationChunk({\n                    message: chunk.toChunk(),\n                    text: chunk.content,\n                });\n            }\n            else {\n                chunkGen = new GenerationChunk({ text: chunk });\n            }\n            if (accGen === undefined) {\n                accGen = chunkGen;\n            }\n            else {\n                accGen = accGen.concat(chunkGen);\n            }\n            const parsed = await this.parsePartialResult([accGen]);\n            if (parsed !== undefined &&\n                parsed !== null &&\n                !deepCompareStrict(parsed, prevParsed)) {\n                if (this.diff) {\n                    yield this._diff(prevParsed, parsed);\n                }\n                else {\n                    yield parsed;\n                }\n                prevParsed = parsed;\n            }\n        }\n    }\n}\n", "import { BaseTransformOutputParser } from \"./transform.js\";\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nexport class BytesOutputParser extends BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"bytes\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"textEncoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new TextEncoder()\n        });\n    }\n    static lc_name() {\n        return \"BytesOutputParser\";\n    }\n    parse(text) {\n        return Promise.resolve(this.textEncoder.encode(text));\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n", "import { OutputParserException } from \"./base.js\";\nimport { BaseTransformOutputParser } from \"./transform.js\";\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nexport class ListOutputParser extends BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async *_transform(inputGenerator) {\n        let buffer = \"\";\n        for await (const input of inputGenerator) {\n            if (typeof input === \"string\") {\n                // add current chunk to buffer\n                buffer += input;\n            }\n            else {\n                // extract message content and add to buffer\n                buffer += input.content;\n            }\n            // get parts in buffer\n            if (!this.re) {\n                const parts = await this.parse(buffer);\n                if (parts.length > 1) {\n                    // if there are multiple parts, yield all but the last one\n                    for (const part of parts.slice(0, -1)) {\n                        yield [part];\n                    }\n                    // keep the last part in the buffer\n                    buffer = parts[parts.length - 1];\n                }\n            }\n            else {\n                // if there is a regex, get all matches\n                const matches = [...buffer.matchAll(this.re)];\n                if (matches.length > 1) {\n                    let doneIdx = 0;\n                    // if there are multiple matches, yield all but the last one\n                    for (const match of matches.slice(0, -1)) {\n                        yield [match[1]];\n                        doneIdx += (match.index ?? 0) + match[0].length;\n                    }\n                    // keep the last match in the buffer\n                    buffer = buffer.slice(doneIdx);\n                }\n            }\n        }\n        // yield the last part\n        for (const part of await this.parse(buffer)) {\n            yield [part];\n        }\n    }\n}\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nexport class CommaSeparatedListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"CommaSeparatedListOutputParser\";\n    }\n    /**\n     * Parses the given text into an array of strings, using a comma as the\n     * separator. If the parsing fails, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each comma.\n     */\n    async parse(text) {\n        try {\n            return text\n                .trim()\n                .split(\",\")\n                .map((s) => s.trim());\n        }\n        catch (e) {\n            throw new OutputParserException(`Could not parse output: ${text}`, text);\n        }\n    }\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CommaSeparatedListOutputParser.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions() {\n        return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n    }\n}\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nexport class CustomListOutputParser extends ListOutputParser {\n    constructor({ length, separator }) {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"length\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.length = length;\n        this.separator = separator || \",\";\n    }\n    /**\n     * Parses the given text into an array of strings, using the specified\n     * separator. If the parsing fails or the number of items in the list\n     * doesn't match the expected length, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n     */\n    async parse(text) {\n        try {\n            const items = text\n                .trim()\n                .split(this.separator)\n                .map((s) => s.trim());\n            if (this.length !== undefined && items.length !== this.length) {\n                throw new OutputParserException(`Incorrect number of items. Expected ${this.length}, got ${items.length}.`);\n            }\n            return items;\n        }\n        catch (e) {\n            if (Object.getPrototypeOf(e) === OutputParserException.prototype) {\n                throw e;\n            }\n            throw new OutputParserException(`Could not parse output: ${text}`);\n        }\n    }\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CustomListOutputParser, including the number of items and the\n     * separator.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions() {\n        return `Your response should be a list of ${this.length === undefined ? \"\" : `${this.length} `}items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${this.separator} baz\\`)`;\n    }\n}\nexport class NumberedListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: /\\d+\\.\\s([^\\n]+)/g\n        });\n    }\n    static lc_name() {\n        return \"NumberedListOutputParser\";\n    }\n    getFormatInstructions() {\n        return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n    }\n    async parse(text) {\n        return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n    }\n}\nexport class MarkdownListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: /^\\s*[-*]\\s([^\\n]+)$/gm\n        });\n    }\n    static lc_name() {\n        return \"NumberedListOutputParser\";\n    }\n    getFormatInstructions() {\n        return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n    }\n    async parse(text) {\n        return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n    }\n}\n", "import { BaseTransformOutputParser } from \"./transform.js\";\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({}),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nexport class StringOutputParser extends BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"string\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"StrOutputParser\";\n    }\n    /**\n     * Parses a string output from an LLM call. This method is meant to be\n     * implemented by subclasses to define how a string output from an LLM\n     * should be parsed.\n     * @param text The string output from an LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parse(text) {\n        return Promise.resolve(text);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n", "import { BaseCumulativeTransformOutputParser } from \"./transform.js\";\nimport { compare } from \"../utils/json_patch.js\";\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nexport class JsonOutputParser extends BaseCumulativeTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"JsonOutputParser\";\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return compare(prev, next);\n    }\n    // This should actually return Partial<T>, but there's no way\n    // to specify emitted chunks as instances separate from the main output type.\n    async parsePartialResult(generations) {\n        return parseJsonMarkdown(generations[0].text);\n    }\n    async parse(text) {\n        return parseJsonMarkdown(text, JSON.parse);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexport function parseJsonMarkdown(s, parser = parsePartialJson) {\n    // eslint-disable-next-line no-param-reassign\n    s = s.trim();\n    const match = /```(json)?(.*)```/s.exec(s);\n    if (!match) {\n        return parser(s);\n    }\n    else {\n        return parser(match[2]);\n    }\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nexport function parsePartialJson(s) {\n    // If the input is undefined, return null to indicate failure.\n    if (typeof s === \"undefined\") {\n        return null;\n    }\n    // Attempt to parse the string as-is.\n    try {\n        return JSON.parse(s);\n    }\n    catch (error) {\n        // Pass\n    }\n    // Initialize variables.\n    let new_s = \"\";\n    const stack = [];\n    let isInsideString = false;\n    let escaped = false;\n    // Process each character in the string one at a time.\n    for (let char of s) {\n        if (isInsideString) {\n            if (char === '\"' && !escaped) {\n                isInsideString = false;\n            }\n            else if (char === \"\\n\" && !escaped) {\n                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n            }\n            else if (char === \"\\\\\") {\n                escaped = !escaped;\n            }\n            else {\n                escaped = false;\n            }\n        }\n        else {\n            if (char === '\"') {\n                isInsideString = true;\n                escaped = false;\n            }\n            else if (char === \"{\") {\n                stack.push(\"}\");\n            }\n            else if (char === \"[\") {\n                stack.push(\"]\");\n            }\n            else if (char === \"}\" || char === \"]\") {\n                if (stack && stack[stack.length - 1] === char) {\n                    stack.pop();\n                }\n                else {\n                    // Mismatched closing character; the input is malformed.\n                    return null;\n                }\n            }\n        }\n        // Append the processed character to the new string.\n        new_s += char;\n    }\n    // If we're still inside a string at the end of processing,\n    // we need to close the string.\n    if (isInsideString) {\n        new_s += '\"';\n    }\n    // Close any remaining open structures in the reverse order that they were opened.\n    for (let i = stack.length - 1; i >= 0; i -= 1) {\n        new_s += stack[i];\n    }\n    // Attempt to parse the modified string as JSON.\n    try {\n        return JSON.parse(new_s);\n    }\n    catch (error) {\n        // If we still can't parse the string as JSON, return null to indicate failure.\n        return null;\n    }\n}\n", "// @ts-nocheck\n// Inlined to deal with portability issues\n// Originally from: https://github.com/isaacs/sax-js\nconst initializeSax = function () {\n    const sax = {};\n    sax.parser = function (strict, opt) {\n        return new SAXParser(strict, opt);\n    };\n    sax.SAXParser = SAXParser;\n    sax.SAXStream = SAXStream;\n    sax.createStream = createStream;\n    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n    // since that's the earliest that a buffer overrun could occur.  This way, checks are\n    // as rare as required, but as often as necessary to ensure never crossing this bound.\n    // Furthermore, buffers are only tested at most once per write(), so passing a very\n    // large string into write() might have undesirable effects, but this is manageable by\n    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n    // edge case, result in creating at most one complete copy of the string passed in.\n    // Set to Infinity to have unlimited buffers.\n    sax.MAX_BUFFER_LENGTH = 64 * 1024;\n    const buffers = [\n        \"comment\",\n        \"sgmlDecl\",\n        \"textNode\",\n        \"tagName\",\n        \"doctype\",\n        \"procInstName\",\n        \"procInstBody\",\n        \"entity\",\n        \"attribName\",\n        \"attribValue\",\n        \"cdata\",\n        \"script\",\n    ];\n    sax.EVENTS = [\n        \"text\",\n        \"processinginstruction\",\n        \"sgmldeclaration\",\n        \"doctype\",\n        \"comment\",\n        \"opentagstart\",\n        \"attribute\",\n        \"opentag\",\n        \"closetag\",\n        \"opencdata\",\n        \"cdata\",\n        \"closecdata\",\n        \"error\",\n        \"end\",\n        \"ready\",\n        \"script\",\n        \"opennamespace\",\n        \"closenamespace\",\n    ];\n    function SAXParser(strict, opt) {\n        if (!(this instanceof SAXParser)) {\n            return new SAXParser(strict, opt);\n        }\n        var parser = this;\n        clearBuffers(parser);\n        parser.q = parser.c = \"\";\n        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n        parser.opt = opt || {};\n        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n        parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n        parser.tags = [];\n        parser.closed = parser.closedRoot = parser.sawRoot = false;\n        parser.tag = parser.error = null;\n        parser.strict = !!strict;\n        parser.noscript = !!(strict || parser.opt.noscript);\n        parser.state = S.BEGIN;\n        parser.strictEntities = parser.opt.strictEntities;\n        parser.ENTITIES = parser.strictEntities\n            ? Object.create(sax.XML_ENTITIES)\n            : Object.create(sax.ENTITIES);\n        parser.attribList = [];\n        // namespaces form a prototype chain.\n        // it always points at the current tag,\n        // which protos to its parent tag.\n        if (parser.opt.xmlns) {\n            parser.ns = Object.create(rootNS);\n        }\n        // mostly just for error reporting\n        parser.trackPosition = parser.opt.position !== false;\n        if (parser.trackPosition) {\n            parser.position = parser.line = parser.column = 0;\n        }\n        emit(parser, \"onready\");\n    }\n    if (!Object.create) {\n        Object.create = function (o) {\n            function F() { }\n            F.prototype = o;\n            var newf = new F();\n            return newf;\n        };\n    }\n    if (!Object.keys) {\n        Object.keys = function (o) {\n            var a = [];\n            for (var i in o)\n                if (o.hasOwnProperty(i))\n                    a.push(i);\n            return a;\n        };\n    }\n    function checkBufferLength(parser) {\n        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n        var maxActual = 0;\n        for (var i = 0, l = buffers.length; i < l; i++) {\n            var len = parser[buffers[i]].length;\n            if (len > maxAllowed) {\n                // Text/cdata nodes can get big, and since they're buffered,\n                // we can get here under normal conditions.\n                // Avoid issues by emitting the text node now,\n                // so at least it won't get any bigger.\n                switch (buffers[i]) {\n                    case \"textNode\":\n                        closeText(parser);\n                        break;\n                    case \"cdata\":\n                        emitNode(parser, \"oncdata\", parser.cdata);\n                        parser.cdata = \"\";\n                        break;\n                    case \"script\":\n                        emitNode(parser, \"onscript\", parser.script);\n                        parser.script = \"\";\n                        break;\n                    default:\n                        error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n                }\n            }\n            maxActual = Math.max(maxActual, len);\n        }\n        // schedule the next check for the earliest possible buffer overrun.\n        var m = sax.MAX_BUFFER_LENGTH - maxActual;\n        parser.bufferCheckPosition = m + parser.position;\n    }\n    function clearBuffers(parser) {\n        for (var i = 0, l = buffers.length; i < l; i++) {\n            parser[buffers[i]] = \"\";\n        }\n    }\n    function flushBuffers(parser) {\n        closeText(parser);\n        if (parser.cdata !== \"\") {\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n        }\n        if (parser.script !== \"\") {\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n        }\n    }\n    SAXParser.prototype = {\n        end: function () {\n            end(this);\n        },\n        write: write,\n        resume: function () {\n            this.error = null;\n            return this;\n        },\n        close: function () {\n            return this.write(null);\n        },\n        flush: function () {\n            flushBuffers(this);\n        },\n    };\n    var Stream = ReadableStream;\n    if (!Stream)\n        Stream = function () { };\n    var streamWraps = sax.EVENTS.filter(function (ev) {\n        return ev !== \"error\" && ev !== \"end\";\n    });\n    function createStream(strict, opt) {\n        return new SAXStream(strict, opt);\n    }\n    function SAXStream(strict, opt) {\n        if (!(this instanceof SAXStream)) {\n            return new SAXStream(strict, opt);\n        }\n        Stream.apply(this);\n        this._parser = new SAXParser(strict, opt);\n        this.writable = true;\n        this.readable = true;\n        var me = this;\n        this._parser.onend = function () {\n            me.emit(\"end\");\n        };\n        this._parser.onerror = function (er) {\n            me.emit(\"error\", er);\n            // if didn't throw, then means error was handled.\n            // go ahead and clear error, so we can write again.\n            me._parser.error = null;\n        };\n        this._decoder = null;\n        streamWraps.forEach(function (ev) {\n            Object.defineProperty(me, \"on\" + ev, {\n                get: function () {\n                    return me._parser[\"on\" + ev];\n                },\n                set: function (h) {\n                    if (!h) {\n                        me.removeAllListeners(ev);\n                        me._parser[\"on\" + ev] = h;\n                        return h;\n                    }\n                    me.on(ev, h);\n                },\n                enumerable: true,\n                configurable: false,\n            });\n        });\n    }\n    SAXStream.prototype = Object.create(Stream.prototype, {\n        constructor: {\n            value: SAXStream,\n        },\n    });\n    SAXStream.prototype.write = function (data) {\n        this._parser.write(data.toString());\n        this.emit(\"data\", data);\n        return true;\n    };\n    SAXStream.prototype.end = function (chunk) {\n        if (chunk && chunk.length) {\n            this.write(chunk);\n        }\n        this._parser.end();\n        return true;\n    };\n    SAXStream.prototype.on = function (ev, handler) {\n        var me = this;\n        if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n            me._parser[\"on\" + ev] = function () {\n                var args = arguments.length === 1\n                    ? [arguments[0]]\n                    : Array.apply(null, arguments);\n                args.splice(0, 0, ev);\n                me.emit.apply(me, args);\n            };\n        }\n        return Stream.prototype.on.call(me, ev, handler);\n    };\n    // this really needs to be replaced with character classes.\n    // XML allows all manner of ridiculous numbers and digits.\n    var CDATA = \"[CDATA[\";\n    var DOCTYPE = \"DOCTYPE\";\n    var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n    var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n    // This implementation works on strings, a single character at a time\n    // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n    // without a significant breaking change to either this  parser, or the\n    // JavaScript language.  Implementation of an emoji-capable xml parser\n    // is left as an exercise for the reader.\n    var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    function isWhitespace(c) {\n        return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n    }\n    function isQuote(c) {\n        return c === '\"' || c === \"'\";\n    }\n    function isAttribEnd(c) {\n        return c === \">\" || isWhitespace(c);\n    }\n    function isMatch(regex, c) {\n        return regex.test(c);\n    }\n    function notMatch(regex, c) {\n        return !isMatch(regex, c);\n    }\n    var S = 0;\n    sax.STATE = {\n        BEGIN: S++,\n        BEGIN_WHITESPACE: S++,\n        TEXT: S++,\n        TEXT_ENTITY: S++,\n        OPEN_WAKA: S++,\n        SGML_DECL: S++,\n        SGML_DECL_QUOTED: S++,\n        DOCTYPE: S++,\n        DOCTYPE_QUOTED: S++,\n        DOCTYPE_DTD: S++,\n        DOCTYPE_DTD_QUOTED: S++,\n        COMMENT_STARTING: S++,\n        COMMENT: S++,\n        COMMENT_ENDING: S++,\n        COMMENT_ENDED: S++,\n        CDATA: S++,\n        CDATA_ENDING: S++,\n        CDATA_ENDING_2: S++,\n        PROC_INST: S++,\n        PROC_INST_BODY: S++,\n        PROC_INST_ENDING: S++,\n        OPEN_TAG: S++,\n        OPEN_TAG_SLASH: S++,\n        ATTRIB: S++,\n        ATTRIB_NAME: S++,\n        ATTRIB_NAME_SAW_WHITE: S++,\n        ATTRIB_VALUE: S++,\n        ATTRIB_VALUE_QUOTED: S++,\n        ATTRIB_VALUE_CLOSED: S++,\n        ATTRIB_VALUE_UNQUOTED: S++,\n        ATTRIB_VALUE_ENTITY_Q: S++,\n        ATTRIB_VALUE_ENTITY_U: S++,\n        CLOSE_TAG: S++,\n        CLOSE_TAG_SAW_WHITE: S++,\n        SCRIPT: S++,\n        SCRIPT_ENDING: S++, // <script> ... <\n    };\n    sax.XML_ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\",\n    };\n    sax.ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\",\n        AElig: 198,\n        Aacute: 193,\n        Acirc: 194,\n        Agrave: 192,\n        Aring: 197,\n        Atilde: 195,\n        Auml: 196,\n        Ccedil: 199,\n        ETH: 208,\n        Eacute: 201,\n        Ecirc: 202,\n        Egrave: 200,\n        Euml: 203,\n        Iacute: 205,\n        Icirc: 206,\n        Igrave: 204,\n        Iuml: 207,\n        Ntilde: 209,\n        Oacute: 211,\n        Ocirc: 212,\n        Ograve: 210,\n        Oslash: 216,\n        Otilde: 213,\n        Ouml: 214,\n        THORN: 222,\n        Uacute: 218,\n        Ucirc: 219,\n        Ugrave: 217,\n        Uuml: 220,\n        Yacute: 221,\n        aacute: 225,\n        acirc: 226,\n        aelig: 230,\n        agrave: 224,\n        aring: 229,\n        atilde: 227,\n        auml: 228,\n        ccedil: 231,\n        eacute: 233,\n        ecirc: 234,\n        egrave: 232,\n        eth: 240,\n        euml: 235,\n        iacute: 237,\n        icirc: 238,\n        igrave: 236,\n        iuml: 239,\n        ntilde: 241,\n        oacute: 243,\n        ocirc: 244,\n        ograve: 242,\n        oslash: 248,\n        otilde: 245,\n        ouml: 246,\n        szlig: 223,\n        thorn: 254,\n        uacute: 250,\n        ucirc: 251,\n        ugrave: 249,\n        uuml: 252,\n        yacute: 253,\n        yuml: 255,\n        copy: 169,\n        reg: 174,\n        nbsp: 160,\n        iexcl: 161,\n        cent: 162,\n        pound: 163,\n        curren: 164,\n        yen: 165,\n        brvbar: 166,\n        sect: 167,\n        uml: 168,\n        ordf: 170,\n        laquo: 171,\n        not: 172,\n        shy: 173,\n        macr: 175,\n        deg: 176,\n        plusmn: 177,\n        sup1: 185,\n        sup2: 178,\n        sup3: 179,\n        acute: 180,\n        micro: 181,\n        para: 182,\n        middot: 183,\n        cedil: 184,\n        ordm: 186,\n        raquo: 187,\n        frac14: 188,\n        frac12: 189,\n        frac34: 190,\n        iquest: 191,\n        times: 215,\n        divide: 247,\n        OElig: 338,\n        oelig: 339,\n        Scaron: 352,\n        scaron: 353,\n        Yuml: 376,\n        fnof: 402,\n        circ: 710,\n        tilde: 732,\n        Alpha: 913,\n        Beta: 914,\n        Gamma: 915,\n        Delta: 916,\n        Epsilon: 917,\n        Zeta: 918,\n        Eta: 919,\n        Theta: 920,\n        Iota: 921,\n        Kappa: 922,\n        Lambda: 923,\n        Mu: 924,\n        Nu: 925,\n        Xi: 926,\n        Omicron: 927,\n        Pi: 928,\n        Rho: 929,\n        Sigma: 931,\n        Tau: 932,\n        Upsilon: 933,\n        Phi: 934,\n        Chi: 935,\n        Psi: 936,\n        Omega: 937,\n        alpha: 945,\n        beta: 946,\n        gamma: 947,\n        delta: 948,\n        epsilon: 949,\n        zeta: 950,\n        eta: 951,\n        theta: 952,\n        iota: 953,\n        kappa: 954,\n        lambda: 955,\n        mu: 956,\n        nu: 957,\n        xi: 958,\n        omicron: 959,\n        pi: 960,\n        rho: 961,\n        sigmaf: 962,\n        sigma: 963,\n        tau: 964,\n        upsilon: 965,\n        phi: 966,\n        chi: 967,\n        psi: 968,\n        omega: 969,\n        thetasym: 977,\n        upsih: 978,\n        piv: 982,\n        ensp: 8194,\n        emsp: 8195,\n        thinsp: 8201,\n        zwnj: 8204,\n        zwj: 8205,\n        lrm: 8206,\n        rlm: 8207,\n        ndash: 8211,\n        mdash: 8212,\n        lsquo: 8216,\n        rsquo: 8217,\n        sbquo: 8218,\n        ldquo: 8220,\n        rdquo: 8221,\n        bdquo: 8222,\n        dagger: 8224,\n        Dagger: 8225,\n        bull: 8226,\n        hellip: 8230,\n        permil: 8240,\n        prime: 8242,\n        Prime: 8243,\n        lsaquo: 8249,\n        rsaquo: 8250,\n        oline: 8254,\n        frasl: 8260,\n        euro: 8364,\n        image: 8465,\n        weierp: 8472,\n        real: 8476,\n        trade: 8482,\n        alefsym: 8501,\n        larr: 8592,\n        uarr: 8593,\n        rarr: 8594,\n        darr: 8595,\n        harr: 8596,\n        crarr: 8629,\n        lArr: 8656,\n        uArr: 8657,\n        rArr: 8658,\n        dArr: 8659,\n        hArr: 8660,\n        forall: 8704,\n        part: 8706,\n        exist: 8707,\n        empty: 8709,\n        nabla: 8711,\n        isin: 8712,\n        notin: 8713,\n        ni: 8715,\n        prod: 8719,\n        sum: 8721,\n        minus: 8722,\n        lowast: 8727,\n        radic: 8730,\n        prop: 8733,\n        infin: 8734,\n        ang: 8736,\n        and: 8743,\n        or: 8744,\n        cap: 8745,\n        cup: 8746,\n        int: 8747,\n        there4: 8756,\n        sim: 8764,\n        cong: 8773,\n        asymp: 8776,\n        ne: 8800,\n        equiv: 8801,\n        le: 8804,\n        ge: 8805,\n        sub: 8834,\n        sup: 8835,\n        nsub: 8836,\n        sube: 8838,\n        supe: 8839,\n        oplus: 8853,\n        otimes: 8855,\n        perp: 8869,\n        sdot: 8901,\n        lceil: 8968,\n        rceil: 8969,\n        lfloor: 8970,\n        rfloor: 8971,\n        lang: 9001,\n        rang: 9002,\n        loz: 9674,\n        spades: 9824,\n        clubs: 9827,\n        hearts: 9829,\n        diams: 9830,\n    };\n    Object.keys(sax.ENTITIES).forEach(function (key) {\n        var e = sax.ENTITIES[key];\n        var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n        sax.ENTITIES[key] = s;\n    });\n    for (var s in sax.STATE) {\n        sax.STATE[sax.STATE[s]] = s;\n    }\n    // shorthand\n    S = sax.STATE;\n    function emit(parser, event, data) {\n        parser[event] && parser[event](data);\n    }\n    function emitNode(parser, nodeType, data) {\n        if (parser.textNode)\n            closeText(parser);\n        emit(parser, nodeType, data);\n    }\n    function closeText(parser) {\n        parser.textNode = textopts(parser.opt, parser.textNode);\n        if (parser.textNode)\n            emit(parser, \"ontext\", parser.textNode);\n        parser.textNode = \"\";\n    }\n    function textopts(opt, text) {\n        if (opt.trim)\n            text = text.trim();\n        if (opt.normalize)\n            text = text.replace(/\\s+/g, \" \");\n        return text;\n    }\n    function error(parser, er) {\n        closeText(parser);\n        if (parser.trackPosition) {\n            er +=\n                \"\\nLine: \" +\n                    parser.line +\n                    \"\\nColumn: \" +\n                    parser.column +\n                    \"\\nChar: \" +\n                    parser.c;\n        }\n        er = new Error(er);\n        parser.error = er;\n        emit(parser, \"onerror\", er);\n        return parser;\n    }\n    function end(parser) {\n        if (parser.sawRoot && !parser.closedRoot)\n            strictFail(parser, \"Unclosed root tag\");\n        if (parser.state !== S.BEGIN &&\n            parser.state !== S.BEGIN_WHITESPACE &&\n            parser.state !== S.TEXT) {\n            error(parser, \"Unexpected end\");\n        }\n        closeText(parser);\n        parser.c = \"\";\n        parser.closed = true;\n        emit(parser, \"onend\");\n        SAXParser.call(parser, parser.strict, parser.opt);\n        return parser;\n    }\n    function strictFail(parser, message) {\n        if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n            throw new Error(\"bad call to strictFail\");\n        }\n        if (parser.strict) {\n            error(parser, message);\n        }\n    }\n    function newTag(parser) {\n        if (!parser.strict)\n            parser.tagName = parser.tagName[parser.looseCase]();\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        var tag = (parser.tag = { name: parser.tagName, attributes: {} });\n        // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n        if (parser.opt.xmlns) {\n            tag.ns = parent.ns;\n        }\n        parser.attribList.length = 0;\n        emitNode(parser, \"onopentagstart\", tag);\n    }\n    function qname(name, attribute) {\n        var i = name.indexOf(\":\");\n        var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n        var prefix = qualName[0];\n        var local = qualName[1];\n        // <x \"xmlns\"=\"http://foo\">\n        if (attribute && name === \"xmlns\") {\n            prefix = \"xmlns\";\n            local = \"\";\n        }\n        return { prefix: prefix, local: local };\n    }\n    function attrib(parser) {\n        if (!parser.strict) {\n            parser.attribName = parser.attribName[parser.looseCase]();\n        }\n        if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n            parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n            parser.attribName = parser.attribValue = \"\";\n            return;\n        }\n        if (parser.opt.xmlns) {\n            var qn = qname(parser.attribName, true);\n            var prefix = qn.prefix;\n            var local = qn.local;\n            if (prefix === \"xmlns\") {\n                // namespace binding attribute. push the binding into scope\n                if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n                    strictFail(parser, \"xml: prefix must be bound to \" +\n                        XML_NAMESPACE +\n                        \"\\n\" +\n                        \"Actual: \" +\n                        parser.attribValue);\n                }\n                else if (local === \"xmlns\" &&\n                    parser.attribValue !== XMLNS_NAMESPACE) {\n                    strictFail(parser, \"xmlns: prefix must be bound to \" +\n                        XMLNS_NAMESPACE +\n                        \"\\n\" +\n                        \"Actual: \" +\n                        parser.attribValue);\n                }\n                else {\n                    var tag = parser.tag;\n                    var parent = parser.tags[parser.tags.length - 1] || parser;\n                    if (tag.ns === parent.ns) {\n                        tag.ns = Object.create(parent.ns);\n                    }\n                    tag.ns[local] = parser.attribValue;\n                }\n            }\n            // defer onattribute events until all attributes have been seen\n            // so any new bindings can take effect. preserve attribute order\n            // so deferred events can be emitted in document order\n            parser.attribList.push([parser.attribName, parser.attribValue]);\n        }\n        else {\n            // in non-xmlns mode, we can emit the event right away\n            parser.tag.attributes[parser.attribName] = parser.attribValue;\n            emitNode(parser, \"onattribute\", {\n                name: parser.attribName,\n                value: parser.attribValue,\n            });\n        }\n        parser.attribName = parser.attribValue = \"\";\n    }\n    function openTag(parser, selfClosing) {\n        if (parser.opt.xmlns) {\n            // emit namespace binding events\n            var tag = parser.tag;\n            // add namespace info to tag\n            var qn = qname(parser.tagName);\n            tag.prefix = qn.prefix;\n            tag.local = qn.local;\n            tag.uri = tag.ns[qn.prefix] || \"\";\n            if (tag.prefix && !tag.uri) {\n                strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n                tag.uri = qn.prefix;\n            }\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n            if (tag.ns && parent.ns !== tag.ns) {\n                Object.keys(tag.ns).forEach(function (p) {\n                    emitNode(parser, \"onopennamespace\", {\n                        prefix: p,\n                        uri: tag.ns[p],\n                    });\n                });\n            }\n            // handle deferred onattribute events\n            // Note: do not apply default ns to attributes:\n            //   http://www.w3.org/TR/REC-xml-names/#defaulting\n            for (var i = 0, l = parser.attribList.length; i < l; i++) {\n                var nv = parser.attribList[i];\n                var name = nv[0];\n                var value = nv[1];\n                var qualName = qname(name, true);\n                var prefix = qualName.prefix;\n                var local = qualName.local;\n                var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n                var a = {\n                    name: name,\n                    value: value,\n                    prefix: prefix,\n                    local: local,\n                    uri: uri,\n                };\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (prefix && prefix !== \"xmlns\" && !uri) {\n                    strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n                    a.uri = prefix;\n                }\n                parser.tag.attributes[name] = a;\n                emitNode(parser, \"onattribute\", a);\n            }\n            parser.attribList.length = 0;\n        }\n        parser.tag.isSelfClosing = !!selfClosing;\n        // process the tag\n        parser.sawRoot = true;\n        parser.tags.push(parser.tag);\n        emitNode(parser, \"onopentag\", parser.tag);\n        if (!selfClosing) {\n            // special case for <script> in non-strict mode.\n            if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n                parser.state = S.SCRIPT;\n            }\n            else {\n                parser.state = S.TEXT;\n            }\n            parser.tag = null;\n            parser.tagName = \"\";\n        }\n        parser.attribName = parser.attribValue = \"\";\n        parser.attribList.length = 0;\n    }\n    function closeTag(parser) {\n        if (!parser.tagName) {\n            strictFail(parser, \"Weird empty close tag.\");\n            parser.textNode += \"</>\";\n            parser.state = S.TEXT;\n            return;\n        }\n        if (parser.script) {\n            if (parser.tagName !== \"script\") {\n                parser.script += \"</\" + parser.tagName + \">\";\n                parser.tagName = \"\";\n                parser.state = S.SCRIPT;\n                return;\n            }\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n        }\n        // first make sure that the closing tag actually exists.\n        // <a><b></c></b></a> will close everything, otherwise.\n        var t = parser.tags.length;\n        var tagName = parser.tagName;\n        if (!parser.strict) {\n            tagName = tagName[parser.looseCase]();\n        }\n        var closeTo = tagName;\n        while (t--) {\n            var close = parser.tags[t];\n            if (close.name !== closeTo) {\n                // fail the first time in strict mode\n                strictFail(parser, \"Unexpected close tag\");\n            }\n            else {\n                break;\n            }\n        }\n        // didn't find it.  we already failed for strict, so just abort.\n        if (t < 0) {\n            strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n            parser.textNode += \"</\" + parser.tagName + \">\";\n            parser.state = S.TEXT;\n            return;\n        }\n        parser.tagName = tagName;\n        var s = parser.tags.length;\n        while (s-- > t) {\n            var tag = (parser.tag = parser.tags.pop());\n            parser.tagName = parser.tag.name;\n            emitNode(parser, \"onclosetag\", parser.tagName);\n            var x = {};\n            for (var i in tag.ns) {\n                x[i] = tag.ns[i];\n            }\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n            if (parser.opt.xmlns && tag.ns !== parent.ns) {\n                // remove namespace bindings introduced by tag\n                Object.keys(tag.ns).forEach(function (p) {\n                    var n = tag.ns[p];\n                    emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n                });\n            }\n        }\n        if (t === 0)\n            parser.closedRoot = true;\n        parser.tagName = parser.attribValue = parser.attribName = \"\";\n        parser.attribList.length = 0;\n        parser.state = S.TEXT;\n    }\n    function parseEntity(parser) {\n        var entity = parser.entity;\n        var entityLC = entity.toLowerCase();\n        var num;\n        var numStr = \"\";\n        if (parser.ENTITIES[entity]) {\n            return parser.ENTITIES[entity];\n        }\n        if (parser.ENTITIES[entityLC]) {\n            return parser.ENTITIES[entityLC];\n        }\n        entity = entityLC;\n        if (entity.charAt(0) === \"#\") {\n            if (entity.charAt(1) === \"x\") {\n                entity = entity.slice(2);\n                num = parseInt(entity, 16);\n                numStr = num.toString(16);\n            }\n            else {\n                entity = entity.slice(1);\n                num = parseInt(entity, 10);\n                numStr = num.toString(10);\n            }\n        }\n        entity = entity.replace(/^0+/, \"\");\n        if (isNaN(num) || numStr.toLowerCase() !== entity) {\n            strictFail(parser, \"Invalid character entity\");\n            return \"&\" + parser.entity + \";\";\n        }\n        return String.fromCodePoint(num);\n    }\n    function beginWhiteSpace(parser, c) {\n        if (c === \"<\") {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n        }\n        else if (!isWhitespace(c)) {\n            // have to process this as a text node.\n            // weird, but happens.\n            strictFail(parser, \"Non-whitespace before first tag.\");\n            parser.textNode = c;\n            parser.state = S.TEXT;\n        }\n    }\n    function charAt(chunk, i) {\n        var result = \"\";\n        if (i < chunk.length) {\n            result = chunk.charAt(i);\n        }\n        return result;\n    }\n    function write(chunk) {\n        var parser = this;\n        if (this.error) {\n            throw this.error;\n        }\n        if (parser.closed) {\n            return error(parser, \"Cannot write after close. Assign an onready handler.\");\n        }\n        if (chunk === null) {\n            return end(parser);\n        }\n        if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        var i = 0;\n        var c = \"\";\n        while (true) {\n            c = charAt(chunk, i++);\n            parser.c = c;\n            if (!c) {\n                break;\n            }\n            if (parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                    parser.line++;\n                    parser.column = 0;\n                }\n                else {\n                    parser.column++;\n                }\n            }\n            switch (parser.state) {\n                case S.BEGIN:\n                    parser.state = S.BEGIN_WHITESPACE;\n                    if (c === \"\\uFEFF\") {\n                        continue;\n                    }\n                    beginWhiteSpace(parser, c);\n                    continue;\n                case S.BEGIN_WHITESPACE:\n                    beginWhiteSpace(parser, c);\n                    continue;\n                case S.TEXT:\n                    if (parser.sawRoot && !parser.closedRoot) {\n                        var starti = i - 1;\n                        while (c && c !== \"<\" && c !== \"&\") {\n                            c = charAt(chunk, i++);\n                            if (c && parser.trackPosition) {\n                                parser.position++;\n                                if (c === \"\\n\") {\n                                    parser.line++;\n                                    parser.column = 0;\n                                }\n                                else {\n                                    parser.column++;\n                                }\n                            }\n                        }\n                        parser.textNode += chunk.substring(starti, i - 1);\n                    }\n                    if (c === \"<\" &&\n                        !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                        parser.state = S.OPEN_WAKA;\n                        parser.startTagPosition = parser.position;\n                    }\n                    else {\n                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n                            strictFail(parser, \"Text data outside of root node.\");\n                        }\n                        if (c === \"&\") {\n                            parser.state = S.TEXT_ENTITY;\n                        }\n                        else {\n                            parser.textNode += c;\n                        }\n                    }\n                    continue;\n                case S.SCRIPT:\n                    // only non-strict\n                    if (c === \"<\") {\n                        parser.state = S.SCRIPT_ENDING;\n                    }\n                    else {\n                        parser.script += c;\n                    }\n                    continue;\n                case S.SCRIPT_ENDING:\n                    if (c === \"/\") {\n                        parser.state = S.CLOSE_TAG;\n                    }\n                    else {\n                        parser.script += \"<\" + c;\n                        parser.state = S.SCRIPT;\n                    }\n                    continue;\n                case S.OPEN_WAKA:\n                    // either a /, ?, !, or text is coming next.\n                    if (c === \"!\") {\n                        parser.state = S.SGML_DECL;\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if (isWhitespace(c)) {\n                        // wait for it...\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        parser.state = S.OPEN_TAG;\n                        parser.tagName = c;\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.CLOSE_TAG;\n                        parser.tagName = \"\";\n                    }\n                    else if (c === \"?\") {\n                        parser.state = S.PROC_INST;\n                        parser.procInstName = parser.procInstBody = \"\";\n                    }\n                    else {\n                        strictFail(parser, \"Unencoded <\");\n                        // if there was some whitespace, then add that in.\n                        if (parser.startTagPosition + 1 < parser.position) {\n                            var pad = parser.position - parser.startTagPosition;\n                            c = new Array(pad).join(\" \") + c;\n                        }\n                        parser.textNode += \"<\" + c;\n                        parser.state = S.TEXT;\n                    }\n                    continue;\n                case S.SGML_DECL:\n                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                        emitNode(parser, \"onopencdata\");\n                        parser.state = S.CDATA;\n                        parser.sgmlDecl = \"\";\n                        parser.cdata = \"\";\n                    }\n                    else if (parser.sgmlDecl + c === \"--\") {\n                        parser.state = S.COMMENT;\n                        parser.comment = \"\";\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                        parser.state = S.DOCTYPE;\n                        if (parser.doctype || parser.sawRoot) {\n                            strictFail(parser, \"Inappropriately located doctype declaration\");\n                        }\n                        parser.doctype = \"\";\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if (c === \">\") {\n                        emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                        parser.sgmlDecl = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else if (isQuote(c)) {\n                        parser.state = S.SGML_DECL_QUOTED;\n                        parser.sgmlDecl += c;\n                    }\n                    else {\n                        parser.sgmlDecl += c;\n                    }\n                    continue;\n                case S.SGML_DECL_QUOTED:\n                    if (c === parser.q) {\n                        parser.state = S.SGML_DECL;\n                        parser.q = \"\";\n                    }\n                    parser.sgmlDecl += c;\n                    continue;\n                case S.DOCTYPE:\n                    if (c === \">\") {\n                        parser.state = S.TEXT;\n                        emitNode(parser, \"ondoctype\", parser.doctype);\n                        parser.doctype = true; // just remember that we saw it.\n                    }\n                    else {\n                        parser.doctype += c;\n                        if (c === \"[\") {\n                            parser.state = S.DOCTYPE_DTD;\n                        }\n                        else if (isQuote(c)) {\n                            parser.state = S.DOCTYPE_QUOTED;\n                            parser.q = c;\n                        }\n                    }\n                    continue;\n                case S.DOCTYPE_QUOTED:\n                    parser.doctype += c;\n                    if (c === parser.q) {\n                        parser.q = \"\";\n                        parser.state = S.DOCTYPE;\n                    }\n                    continue;\n                case S.DOCTYPE_DTD:\n                    parser.doctype += c;\n                    if (c === \"]\") {\n                        parser.state = S.DOCTYPE;\n                    }\n                    else if (isQuote(c)) {\n                        parser.state = S.DOCTYPE_DTD_QUOTED;\n                        parser.q = c;\n                    }\n                    continue;\n                case S.DOCTYPE_DTD_QUOTED:\n                    parser.doctype += c;\n                    if (c === parser.q) {\n                        parser.state = S.DOCTYPE_DTD;\n                        parser.q = \"\";\n                    }\n                    continue;\n                case S.COMMENT:\n                    if (c === \"-\") {\n                        parser.state = S.COMMENT_ENDING;\n                    }\n                    else {\n                        parser.comment += c;\n                    }\n                    continue;\n                case S.COMMENT_ENDING:\n                    if (c === \"-\") {\n                        parser.state = S.COMMENT_ENDED;\n                        parser.comment = textopts(parser.opt, parser.comment);\n                        if (parser.comment) {\n                            emitNode(parser, \"oncomment\", parser.comment);\n                        }\n                        parser.comment = \"\";\n                    }\n                    else {\n                        parser.comment += \"-\" + c;\n                        parser.state = S.COMMENT;\n                    }\n                    continue;\n                case S.COMMENT_ENDED:\n                    if (c !== \">\") {\n                        strictFail(parser, \"Malformed comment\");\n                        // allow <!-- blah -- bloo --> in non-strict mode,\n                        // which is a comment of \" blah -- bloo \"\n                        parser.comment += \"--\" + c;\n                        parser.state = S.COMMENT;\n                    }\n                    else {\n                        parser.state = S.TEXT;\n                    }\n                    continue;\n                case S.CDATA:\n                    if (c === \"]\") {\n                        parser.state = S.CDATA_ENDING;\n                    }\n                    else {\n                        parser.cdata += c;\n                    }\n                    continue;\n                case S.CDATA_ENDING:\n                    if (c === \"]\") {\n                        parser.state = S.CDATA_ENDING_2;\n                    }\n                    else {\n                        parser.cdata += \"]\" + c;\n                        parser.state = S.CDATA;\n                    }\n                    continue;\n                case S.CDATA_ENDING_2:\n                    if (c === \">\") {\n                        if (parser.cdata) {\n                            emitNode(parser, \"oncdata\", parser.cdata);\n                        }\n                        emitNode(parser, \"onclosecdata\");\n                        parser.cdata = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else if (c === \"]\") {\n                        parser.cdata += \"]\";\n                    }\n                    else {\n                        parser.cdata += \"]]\" + c;\n                        parser.state = S.CDATA;\n                    }\n                    continue;\n                case S.PROC_INST:\n                    if (c === \"?\") {\n                        parser.state = S.PROC_INST_ENDING;\n                    }\n                    else if (isWhitespace(c)) {\n                        parser.state = S.PROC_INST_BODY;\n                    }\n                    else {\n                        parser.procInstName += c;\n                    }\n                    continue;\n                case S.PROC_INST_BODY:\n                    if (!parser.procInstBody && isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (c === \"?\") {\n                        parser.state = S.PROC_INST_ENDING;\n                    }\n                    else {\n                        parser.procInstBody += c;\n                    }\n                    continue;\n                case S.PROC_INST_ENDING:\n                    if (c === \">\") {\n                        emitNode(parser, \"onprocessinginstruction\", {\n                            name: parser.procInstName,\n                            body: parser.procInstBody,\n                        });\n                        parser.procInstName = parser.procInstBody = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else {\n                        parser.procInstBody += \"?\" + c;\n                        parser.state = S.PROC_INST_BODY;\n                    }\n                    continue;\n                case S.OPEN_TAG:\n                    if (isMatch(nameBody, c)) {\n                        parser.tagName += c;\n                    }\n                    else {\n                        newTag(parser);\n                        if (c === \">\") {\n                            openTag(parser);\n                        }\n                        else if (c === \"/\") {\n                            parser.state = S.OPEN_TAG_SLASH;\n                        }\n                        else {\n                            if (!isWhitespace(c)) {\n                                strictFail(parser, \"Invalid character in tag name\");\n                            }\n                            parser.state = S.ATTRIB;\n                        }\n                    }\n                    continue;\n                case S.OPEN_TAG_SLASH:\n                    if (c === \">\") {\n                        openTag(parser, true);\n                        closeTag(parser);\n                    }\n                    else {\n                        strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n                        parser.state = S.ATTRIB;\n                    }\n                    continue;\n                case S.ATTRIB:\n                    // haven't read the attribute name yet.\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.OPEN_TAG_SLASH;\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        parser.attribName = c;\n                        parser.attribValue = \"\";\n                        parser.state = S.ATTRIB_NAME;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_NAME:\n                    if (c === \"=\") {\n                        parser.state = S.ATTRIB_VALUE;\n                    }\n                    else if (c === \">\") {\n                        strictFail(parser, \"Attribute without value\");\n                        parser.attribValue = parser.attribName;\n                        attrib(parser);\n                        openTag(parser);\n                    }\n                    else if (isWhitespace(c)) {\n                        parser.state = S.ATTRIB_NAME_SAW_WHITE;\n                    }\n                    else if (isMatch(nameBody, c)) {\n                        parser.attribName += c;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_NAME_SAW_WHITE:\n                    if (c === \"=\") {\n                        parser.state = S.ATTRIB_VALUE;\n                    }\n                    else if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else {\n                        strictFail(parser, \"Attribute without value\");\n                        parser.tag.attributes[parser.attribName] = \"\";\n                        parser.attribValue = \"\";\n                        emitNode(parser, \"onattribute\", {\n                            name: parser.attribName,\n                            value: \"\",\n                        });\n                        parser.attribName = \"\";\n                        if (c === \">\") {\n                            openTag(parser);\n                        }\n                        else if (isMatch(nameStart, c)) {\n                            parser.attribName = c;\n                            parser.state = S.ATTRIB_NAME;\n                        }\n                        else {\n                            strictFail(parser, \"Invalid attribute name\");\n                            parser.state = S.ATTRIB;\n                        }\n                    }\n                    continue;\n                case S.ATTRIB_VALUE:\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (isQuote(c)) {\n                        parser.q = c;\n                        parser.state = S.ATTRIB_VALUE_QUOTED;\n                    }\n                    else {\n                        strictFail(parser, \"Unquoted attribute value\");\n                        parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                        parser.attribValue = c;\n                    }\n                    continue;\n                case S.ATTRIB_VALUE_QUOTED:\n                    if (c !== parser.q) {\n                        if (c === \"&\") {\n                            parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                        }\n                        else {\n                            parser.attribValue += c;\n                        }\n                        continue;\n                    }\n                    attrib(parser);\n                    parser.q = \"\";\n                    parser.state = S.ATTRIB_VALUE_CLOSED;\n                    continue;\n                case S.ATTRIB_VALUE_CLOSED:\n                    if (isWhitespace(c)) {\n                        parser.state = S.ATTRIB;\n                    }\n                    else if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.OPEN_TAG_SLASH;\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        strictFail(parser, \"No whitespace between attributes\");\n                        parser.attribName = c;\n                        parser.attribValue = \"\";\n                        parser.state = S.ATTRIB_NAME;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_VALUE_UNQUOTED:\n                    if (!isAttribEnd(c)) {\n                        if (c === \"&\") {\n                            parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                        }\n                        else {\n                            parser.attribValue += c;\n                        }\n                        continue;\n                    }\n                    attrib(parser);\n                    if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else {\n                        parser.state = S.ATTRIB;\n                    }\n                    continue;\n                case S.CLOSE_TAG:\n                    if (!parser.tagName) {\n                        if (isWhitespace(c)) {\n                            continue;\n                        }\n                        else if (notMatch(nameStart, c)) {\n                            if (parser.script) {\n                                parser.script += \"</\" + c;\n                                parser.state = S.SCRIPT;\n                            }\n                            else {\n                                strictFail(parser, \"Invalid tagname in closing tag.\");\n                            }\n                        }\n                        else {\n                            parser.tagName = c;\n                        }\n                    }\n                    else if (c === \">\") {\n                        closeTag(parser);\n                    }\n                    else if (isMatch(nameBody, c)) {\n                        parser.tagName += c;\n                    }\n                    else if (parser.script) {\n                        parser.script += \"</\" + parser.tagName;\n                        parser.tagName = \"\";\n                        parser.state = S.SCRIPT;\n                    }\n                    else {\n                        if (!isWhitespace(c)) {\n                            strictFail(parser, \"Invalid tagname in closing tag\");\n                        }\n                        parser.state = S.CLOSE_TAG_SAW_WHITE;\n                    }\n                    continue;\n                case S.CLOSE_TAG_SAW_WHITE:\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    if (c === \">\") {\n                        closeTag(parser);\n                    }\n                    else {\n                        strictFail(parser, \"Invalid characters in closing tag\");\n                    }\n                    continue;\n                case S.TEXT_ENTITY:\n                case S.ATTRIB_VALUE_ENTITY_Q:\n                case S.ATTRIB_VALUE_ENTITY_U:\n                    var returnState;\n                    var buffer;\n                    switch (parser.state) {\n                        case S.TEXT_ENTITY:\n                            returnState = S.TEXT;\n                            buffer = \"textNode\";\n                            break;\n                        case S.ATTRIB_VALUE_ENTITY_Q:\n                            returnState = S.ATTRIB_VALUE_QUOTED;\n                            buffer = \"attribValue\";\n                            break;\n                        case S.ATTRIB_VALUE_ENTITY_U:\n                            returnState = S.ATTRIB_VALUE_UNQUOTED;\n                            buffer = \"attribValue\";\n                            break;\n                    }\n                    if (c === \";\") {\n                        if (parser.opt.unparsedEntities) {\n                            var parsedEntity = parseEntity(parser);\n                            parser.entity = \"\";\n                            parser.state = returnState;\n                            parser.write(parsedEntity);\n                        }\n                        else {\n                            parser[buffer] += parseEntity(parser);\n                            parser.entity = \"\";\n                            parser.state = returnState;\n                        }\n                    }\n                    else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n                        parser.entity += c;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid character in entity name\");\n                        parser[buffer] += \"&\" + parser.entity + c;\n                        parser.entity = \"\";\n                        parser.state = returnState;\n                    }\n                    continue;\n                default: /* istanbul ignore next */ {\n                    throw new Error(parser, \"Unknown state: \" + parser.state);\n                }\n            }\n        } // while\n        if (parser.position >= parser.bufferCheckPosition) {\n            checkBufferLength(parser);\n        }\n        return parser;\n    }\n    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n    /* istanbul ignore next */\n    if (!String.fromCodePoint) {\n        (function () {\n            var stringFromCharCode = String.fromCharCode;\n            var floor = Math.floor;\n            var fromCodePoint = function () {\n                var MAX_SIZE = 0x4000;\n                var codeUnits = [];\n                var highSurrogate;\n                var lowSurrogate;\n                var index = -1;\n                var length = arguments.length;\n                if (!length) {\n                    return \"\";\n                }\n                var result = \"\";\n                while (++index < length) {\n                    var codePoint = Number(arguments[index]);\n                    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                        codePoint < 0 || // not a valid Unicode code point\n                        codePoint > 0x10ffff || // not a valid Unicode code point\n                        floor(codePoint) !== codePoint // not an integer\n                    ) {\n                        throw RangeError(\"Invalid code point: \" + codePoint);\n                    }\n                    if (codePoint <= 0xffff) {\n                        // BMP code point\n                        codeUnits.push(codePoint);\n                    }\n                    else {\n                        // Astral code point; split in surrogate halves\n                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                        codePoint -= 0x10000;\n                        highSurrogate = (codePoint >> 10) + 0xd800;\n                        lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                        codeUnits.push(highSurrogate, lowSurrogate);\n                    }\n                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                        result += stringFromCharCode.apply(null, codeUnits);\n                        codeUnits.length = 0;\n                    }\n                }\n                return result;\n            };\n            /* istanbul ignore next */\n            if (Object.defineProperty) {\n                Object.defineProperty(String, \"fromCodePoint\", {\n                    value: fromCodePoint,\n                    configurable: true,\n                    writable: true,\n                });\n            }\n            else {\n                String.fromCodePoint = fromCodePoint;\n            }\n        })();\n    }\n    return sax;\n};\nconst sax = /** #__PURE__ */ initializeSax();\nexport { sax };\n", "import { BaseCumulativeTransformOutputParser, } from \"./transform.js\";\nimport { compare } from \"../utils/json_patch.js\";\nimport { sax } from \"../utils/sax-js/sax.js\";\nexport const XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\nexport class XMLOutputParser extends BaseCumulativeTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.tags = fields?.tags;\n    }\n    static lc_name() {\n        return \"XMLOutputParser\";\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return compare(prev, next);\n    }\n    async parsePartialResult(generations) {\n        return parseXMLMarkdown(generations[0].text);\n    }\n    async parse(text) {\n        return parseXMLMarkdown(text);\n    }\n    getFormatInstructions() {\n        const withTags = !!(this.tags && this.tags.length > 0);\n        return withTags\n            ? XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n            : XML_FORMAT_INSTRUCTIONS;\n    }\n}\nconst strip = (text) => text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\nconst parseParsedResult = (input) => {\n    if (Object.keys(input).length === 0) {\n        return {};\n    }\n    const result = {};\n    if (input.children.length > 0) {\n        result[input.name] = input.children.map(parseParsedResult);\n        return result;\n    }\n    else {\n        result[input.name] = input.text ?? undefined;\n        return result;\n    }\n};\nexport function parseXMLMarkdown(s) {\n    const cleanedString = strip(s);\n    const parser = sax.parser(true);\n    let parsedResult = {};\n    const elementStack = [];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onopentag = (node) => {\n        const element = {\n            name: node.name,\n            attributes: node.attributes,\n            children: [],\n            text: \"\",\n            isSelfClosing: node.isSelfClosing,\n        };\n        if (elementStack.length > 0) {\n            const parentElement = elementStack[elementStack.length - 1];\n            parentElement.children.push(element);\n        }\n        else {\n            parsedResult = element;\n        }\n        if (!node.isSelfClosing) {\n            elementStack.push(element);\n        }\n    };\n    parser.onclosetag = () => {\n        if (elementStack.length > 0) {\n            const lastElement = elementStack.pop();\n            if (elementStack.length === 0 && lastElement) {\n                parsedResult = lastElement;\n            }\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.ontext = (text) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.text += text;\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onattribute = (attr) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.attributes[attr.name] = attr.value;\n        }\n    };\n    // Try to find XML string within triple backticks.\n    const match = /```(xml)?(.*)```/s.exec(cleanedString);\n    const xmlString = match ? match[2] : cleanedString;\n    parser.write(xmlString).close();\n    // Remove the XML declaration if present\n    if (parsedResult && parsedResult.name === \"?xml\") {\n        parsedResult = parsedResult.children[0];\n    }\n    return parseParsedResult(parsedResult);\n}\n"],
  "mappings": "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R,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,KAAK;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,KAAK;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK;AAAA,IACL,KAAK;AAAA,IACL,MAAM;AAAA,IACN,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,SAAS;AAAA,IACT,MAAM;AAAA,IACN,KAAK;AAAA,IACL,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,KAAK;AAAA,IACL,OAAO;AAAA,IACP,KAAK;AAAA,IACL,SAAS;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,SAAS;AAAA,IACT,MAAM;AAAA,IACN,KAAK;AAAA,IACL,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,KAAK;AAAA,IACL,SAAS;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,OAAO;AAAA,IACP,UAAU;AAAA,IACV,OAAO;AAAA,IACP,KAAK;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,OAAO;AAAA,IACP,SAAS;AAAA,IACT,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,IAAI;AAAA,IACJ,MAAM;AAAA,IACN,KAAK;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK;AAAA,IACL,KAAK;AAAA,IACL,IAAI;AAAA,IACJ,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,KAAK;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,IAAI;AAAA,IACJ,OAAO;AAAA,IACP,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,KAAK;AAAA,IACL,KAAK;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,OAAO;AAAA,EACX;AACA,SAAO,KAAKA,KAAI,QAAQ,EAAE,QAAQ,SAAU,KAAK;AAC7C,QAAI,IAAIA,KAAI,SAAS,GAAG;AACxB,QAAIE,KAAI,OAAO,MAAM,WAAW,OAAO,aAAa,CAAC,IAAI;AACzD,IAAAF,KAAI,SAAS,GAAG,IAAIE;AAAA,EACxB,CAAC;AACD,WAAS,KAAKF,KAAI,OAAO;AACrB,IAAAA,KAAI,MAAMA,KAAI,MAAM,CAAC,CAAC,IAAI;AAAA,EAC9B;AAEA,MAAIA,KAAI;AACR,WAAS,KAAK,QAAQ,OAAO,MAAM;AAC/B,WAAO,KAAK,KAAK,OAAO,KAAK,EAAE,IAAI;AAAA,EACvC;AACA,WAAS,SAAS,QAAQ,UAAU,MAAM;AACtC,QAAI,OAAO;AACP,gBAAU,MAAM;AACpB,SAAK,QAAQ,UAAU,IAAI;AAAA,EAC/B;AACA,WAAS,UAAU,QAAQ;AACvB,WAAO,WAAW,SAAS,OAAO,KAAK,OAAO,QAAQ;AACtD,QAAI,OAAO;AACP,WAAK,QAAQ,UAAU,OAAO,QAAQ;AAC1C,WAAO,WAAW;AAAA,EACtB;AACA,WAAS,SAAS,KAAK,MAAM;AACzB,QAAI,IAAI;AACJ,aAAO,KAAK,KAAK;AACrB,QAAI,IAAI;AACJ,aAAO,KAAK,QAAQ,QAAQ,GAAG;AACnC,WAAO;AAAA,EACX;AACA,WAAS,MAAM,QAAQ,IAAI;AACvB,cAAU,MAAM;AAChB,QAAI,OAAO,eAAe;AACtB,YACI,aACI,OAAO,OACP,eACA,OAAO,SACP,aACA,OAAO;AAAA,IACnB;AACA,SAAK,IAAI,MAAM,EAAE;AACjB,WAAO,QAAQ;AACf,SAAK,QAAQ,WAAW,EAAE;AAC1B,WAAO;AAAA,EACX;AACA,WAAS,IAAI,QAAQ;AACjB,QAAI,OAAO,WAAW,CAAC,OAAO;AAC1B,iBAAW,QAAQ,mBAAmB;AAC1C,QAAI,OAAO,UAAU,EAAE,SACnB,OAAO,UAAU,EAAE,oBACnB,OAAO,UAAU,EAAE,MAAM;AACzB,YAAM,QAAQ,gBAAgB;AAAA,IAClC;AACA,cAAU,MAAM;AAChB,WAAO,IAAI;AACX,WAAO,SAAS;AAChB,SAAK,QAAQ,OAAO;AACpB,cAAU,KAAK,QAAQ,OAAO,QAAQ,OAAO,GAAG;AAChD,WAAO;AAAA,EACX;AACA,WAAS,WAAW,QAAQ,SAAS;AACjC,QAAI,OAAO,WAAW,YAAY,EAAE,kBAAkB,YAAY;AAC9D,YAAM,IAAI,MAAM,wBAAwB;AAAA,IAC5C;AACA,QAAI,OAAO,QAAQ;AACf,YAAM,QAAQ,OAAO;AAAA,IACzB;AAAA,EACJ;AACA,WAAS,OAAO,QAAQ;AACpB,QAAI,CAAC,OAAO;AACR,aAAO,UAAU,OAAO,QAAQ,OAAO,SAAS,EAAE;AACtD,QAAI,SAAS,OAAO,KAAK,OAAO,KAAK,SAAS,CAAC,KAAK;AACpD,QAAI,MAAO,OAAO,MAAM,EAAE,MAAM,OAAO,SAAS,YAAY,CAAC,EAAE;AAE/D,QAAI,OAAO,IAAI,OAAO;AAClB,UAAI,KAAK,OAAO;AAAA,IACpB;AACA,WAAO,WAAW,SAAS;AAC3B,aAAS,QAAQ,kBAAkB,GAAG;AAAA,EAC1C;AACA,WAAS,MAAM,MAAM,WAAW;AAC5B,QAAI,IAAI,KAAK,QAAQ,GAAG;AACxB,QAAI,WAAW,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,KAAK,MAAM,GAAG;AAClD,QAAI,SAAS,SAAS,CAAC;AACvB,QAAI,QAAQ,SAAS,CAAC;AAEtB,QAAI,aAAa,SAAS,SAAS;AAC/B,eAAS;AACT,cAAQ;AAAA,IACZ;AACA,WAAO,EAAE,QAAgB,MAAa;AAAA,EAC1C;AACA,WAAS,OAAO,QAAQ;AACpB,QAAI,CAAC,OAAO,QAAQ;AAChB,aAAO,aAAa,OAAO,WAAW,OAAO,SAAS,EAAE;AAAA,IAC5D;AACA,QAAI,OAAO,WAAW,QAAQ,OAAO,UAAU,MAAM,MACjD,OAAO,IAAI,WAAW,eAAe,OAAO,UAAU,GAAG;AACzD,aAAO,aAAa,OAAO,cAAc;AACzC;AAAA,IACJ;AACA,QAAI,OAAO,IAAI,OAAO;AAClB,UAAI,KAAK,MAAM,OAAO,YAAY,IAAI;AACtC,UAAI,SAAS,GAAG;AAChB,UAAI,QAAQ,GAAG;AACf,UAAI,WAAW,SAAS;AAEpB,YAAI,UAAU,SAAS,OAAO,gBAAgB,eAAe;AACzD,qBAAW,QAAQ,kCACf,gBACA,eAEA,OAAO,WAAW;AAAA,QAC1B,WACS,UAAU,WACf,OAAO,gBAAgB,iBAAiB;AACxC,qBAAW,QAAQ,oCACf,kBACA,eAEA,OAAO,WAAW;AAAA,QAC1B,OACK;AACD,cAAI,MAAM,OAAO;AACjB,cAAI,SAAS,OAAO,KAAK,OAAO,KAAK,SAAS,CAAC,KAAK;AACpD,cAAI,IAAI,OAAO,OAAO,IAAI;AACtB,gBAAI,KAAK,OAAO,OAAO,OAAO,EAAE;AAAA,UACpC;AACA,cAAI,GAAG,KAAK,IAAI,OAAO;AAAA,QAC3B;AAAA,MACJ;AAIA,aAAO,WAAW,KAAK,CAAC,OAAO,YAAY,OAAO,WAAW,CAAC;AAAA,IAClE,OACK;AAED,aAAO,IAAI,WAAW,OAAO,UAAU,IAAI,OAAO;AAClD,eAAS,QAAQ,eAAe;AAAA,QAC5B,MAAM,OAAO;AAAA,QACb,OAAO,OAAO;AAAA,MAClB,CAAC;AAAA,IACL;AACA,WAAO,aAAa,OAAO,cAAc;AAAA,EAC7C;AACA,WAAS,QAAQ,QAAQ,aAAa;AAClC,QAAI,OAAO,IAAI,OAAO;AAElB,UAAI,MAAM,OAAO;AAEjB,UAAI,KAAK,MAAM,OAAO,OAAO;AAC7B,UAAI,SAAS,GAAG;AAChB,UAAI,QAAQ,GAAG;AACf,UAAI,MAAM,IAAI,GAAG,GAAG,MAAM,KAAK;AAC/B,UAAI,IAAI,UAAU,CAAC,IAAI,KAAK;AACxB,mBAAW,QAAQ,+BAA+B,KAAK,UAAU,OAAO,OAAO,CAAC;AAChF,YAAI,MAAM,GAAG;AAAA,MACjB;AACA,UAAI,SAAS,OAAO,KAAK,OAAO,KAAK,SAAS,CAAC,KAAK;AACpD,UAAI,IAAI,MAAM,OAAO,OAAO,IAAI,IAAI;AAChC,eAAO,KAAK,IAAI,EAAE,EAAE,QAAQ,SAAU,GAAG;AACrC,mBAAS,QAAQ,mBAAmB;AAAA,YAChC,QAAQ;AAAA,YACR,KAAK,IAAI,GAAG,CAAC;AAAA,UACjB,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AAIA,eAAS,IAAI,GAAG,IAAI,OAAO,WAAW,QAAQ,IAAI,GAAG,KAAK;AACtD,YAAI,KAAK,OAAO,WAAW,CAAC;AAC5B,YAAI,OAAO,GAAG,CAAC;AACf,YAAI,QAAQ,GAAG,CAAC;AAChB,YAAI,WAAW,MAAM,MAAM,IAAI;AAC/B,YAAI,SAAS,SAAS;AACtB,YAAI,QAAQ,SAAS;AACrB,YAAIG,OAAM,WAAW,KAAK,KAAK,IAAI,GAAG,MAAM,KAAK;AACjD,YAAI,IAAI;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,KAAKA;AAAA,QACT;AAGA,YAAI,UAAU,WAAW,WAAW,CAACA,MAAK;AACtC,qBAAW,QAAQ,+BAA+B,KAAK,UAAU,MAAM,CAAC;AACxE,YAAE,MAAM;AAAA,QACZ;AACA,eAAO,IAAI,WAAW,IAAI,IAAI;AAC9B,iBAAS,QAAQ,eAAe,CAAC;AAAA,MACrC;AACA,aAAO,WAAW,SAAS;AAAA,IAC/B;AACA,WAAO,IAAI,gBAAgB,CAAC,CAAC;AAE7B,WAAO,UAAU;AACjB,WAAO,KAAK,KAAK,OAAO,GAAG;AAC3B,aAAS,QAAQ,aAAa,OAAO,GAAG;AACxC,QAAI,CAAC,aAAa;AAEd,UAAI,CAAC,OAAO,YAAY,OAAO,QAAQ,YAAY,MAAM,UAAU;AAC/D,eAAO,QAAQ,EAAE;AAAA,MACrB,OACK;AACD,eAAO,QAAQ,EAAE;AAAA,MACrB;AACA,aAAO,MAAM;AACb,aAAO,UAAU;AAAA,IACrB;AACA,WAAO,aAAa,OAAO,cAAc;AACzC,WAAO,WAAW,SAAS;AAAA,EAC/B;AACA,WAAS,SAAS,QAAQ;AACtB,QAAI,CAAC,OAAO,SAAS;AACjB,iBAAW,QAAQ,wBAAwB;AAC3C,aAAO,YAAY;AACnB,aAAO,QAAQ,EAAE;AACjB;AAAA,IACJ;AACA,QAAI,OAAO,QAAQ;AACf,UAAI,OAAO,YAAY,UAAU;AAC7B,eAAO,UAAU,OAAO,OAAO,UAAU;AACzC,eAAO,UAAU;AACjB,eAAO,QAAQ,EAAE;AACjB;AAAA,MACJ;AACA,eAAS,QAAQ,YAAY,OAAO,MAAM;AAC1C,aAAO,SAAS;AAAA,IACpB;AAGA,QAAI,IAAI,OAAO,KAAK;AACpB,QAAI,UAAU,OAAO;AACrB,QAAI,CAAC,OAAO,QAAQ;AAChB,gBAAU,QAAQ,OAAO,SAAS,EAAE;AAAA,IACxC;AACA,QAAI,UAAU;AACd,WAAO,KAAK;AACR,UAAI,QAAQ,OAAO,KAAK,CAAC;AACzB,UAAI,MAAM,SAAS,SAAS;AAExB,mBAAW,QAAQ,sBAAsB;AAAA,MAC7C,OACK;AACD;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI,IAAI,GAAG;AACP,iBAAW,QAAQ,4BAA4B,OAAO,OAAO;AAC7D,aAAO,YAAY,OAAO,OAAO,UAAU;AAC3C,aAAO,QAAQ,EAAE;AACjB;AAAA,IACJ;AACA,WAAO,UAAU;AACjB,QAAID,KAAI,OAAO,KAAK;AACpB,WAAOA,OAAM,GAAG;AACZ,UAAI,MAAO,OAAO,MAAM,OAAO,KAAK,IAAI;AACxC,aAAO,UAAU,OAAO,IAAI;AAC5B,eAAS,QAAQ,cAAc,OAAO,OAAO;AAC7C,UAAI,IAAI,CAAC;AACT,eAAS,KAAK,IAAI,IAAI;AAClB,UAAE,CAAC,IAAI,IAAI,GAAG,CAAC;AAAA,MACnB;AACA,UAAI,SAAS,OAAO,KAAK,OAAO,KAAK,SAAS,CAAC,KAAK;AACpD,UAAI,OAAO,IAAI,SAAS,IAAI,OAAO,OAAO,IAAI;AAE1C,eAAO,KAAK,IAAI,EAAE,EAAE,QAAQ,SAAU,GAAG;AACrC,cAAI,IAAI,IAAI,GAAG,CAAC;AAChB,mBAAS,QAAQ,oBAAoB,EAAE,QAAQ,GAAG,KAAK,EAAE,CAAC;AAAA,QAC9D,CAAC;AAAA,MACL;AAAA,IACJ;AACA,QAAI,MAAM;AACN,aAAO,aAAa;AACxB,WAAO,UAAU,OAAO,cAAc,OAAO,aAAa;AAC1D,WAAO,WAAW,SAAS;AAC3B,WAAO,QAAQ,EAAE;AAAA,EACrB;AACA,WAAS,YAAY,QAAQ;AACzB,QAAI,SAAS,OAAO;AACpB,QAAI,WAAW,OAAO,YAAY;AAClC,QAAI;AACJ,QAAI,SAAS;AACb,QAAI,OAAO,SAAS,MAAM,GAAG;AACzB,aAAO,OAAO,SAAS,MAAM;AAAA,IACjC;AACA,QAAI,OAAO,SAAS,QAAQ,GAAG;AAC3B,aAAO,OAAO,SAAS,QAAQ;AAAA,IACnC;AACA,aAAS;AACT,QAAI,OAAO,OAAO,CAAC,MAAM,KAAK;AAC1B,UAAI,OAAO,OAAO,CAAC,MAAM,KAAK;AAC1B,iBAAS,OAAO,MAAM,CAAC;AACvB,cAAM,SAAS,QAAQ,EAAE;AACzB,iBAAS,IAAI,SAAS,EAAE;AAAA,MAC5B,OACK;AACD,iBAAS,OAAO,MAAM,CAAC;AACvB,cAAM,SAAS,QAAQ,EAAE;AACzB,iBAAS,IAAI,SAAS,EAAE;AAAA,MAC5B;AAAA,IACJ;AACA,aAAS,OAAO,QAAQ,OAAO,EAAE;AACjC,QAAI,MAAM,GAAG,KAAK,OAAO,YAAY,MAAM,QAAQ;AAC/C,iBAAW,QAAQ,0BAA0B;AAC7C,aAAO,MAAM,OAAO,SAAS;AAAA,IACjC;AACA,WAAO,OAAO,cAAc,GAAG;AAAA,EACnC;AACA,WAAS,gBAAgB,QAAQ,GAAG;AAChC,QAAI,MAAM,KAAK;AACX,aAAO,QAAQ,EAAE;AACjB,aAAO,mBAAmB,OAAO;AAAA,IACrC,WACS,CAAC,aAAa,CAAC,GAAG;AAGvB,iBAAW,QAAQ,kCAAkC;AACrD,aAAO,WAAW;AAClB,aAAO,QAAQ,EAAE;AAAA,IACrB;AAAA,EACJ;AACA,WAAS,OAAO,OAAO,GAAG;AACtB,QAAI,SAAS;AACb,QAAI,IAAI,MAAM,QAAQ;AAClB,eAAS,MAAM,OAAO,CAAC;AAAA,IAC3B;AACA,WAAO;AAAA,EACX;AACA,WAAS,MAAM,OAAO;AAClB,QAAI,SAAS;AACb,QAAI,KAAK,OAAO;AACZ,YAAM,KAAK;AAAA,IACf;AACA,QAAI,OAAO,QAAQ;AACf,aAAO,MAAM,QAAQ,sDAAsD;AAAA,IAC/E;AACA,QAAI,UAAU,MAAM;AAChB,aAAO,IAAI,MAAM;AAAA,IACrB;AACA,QAAI,OAAO,UAAU,UAAU;AAC3B,cAAQ,MAAM,SAAS;AAAA,IAC3B;AACA,QAAI,IAAI;AACR,QAAI,IAAI;AACR,WAAO,MAAM;AACT,UAAI,OAAO,OAAO,GAAG;AACrB,aAAO,IAAI;AACX,UAAI,CAAC,GAAG;AACJ;AAAA,MACJ;AACA,UAAI,OAAO,eAAe;AACtB,eAAO;AACP,YAAI,MAAM,MAAM;AACZ,iBAAO;AACP,iBAAO,SAAS;AAAA,QACpB,OACK;AACD,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,cAAQ,OAAO,OAAO;AAAA,QAClB,KAAK,EAAE;AACH,iBAAO,QAAQ,EAAE;AACjB,cAAI,MAAM,UAAU;AAChB;AAAA,UACJ;AACA,0BAAgB,QAAQ,CAAC;AACzB;AAAA,QACJ,KAAK,EAAE;AACH,0BAAgB,QAAQ,CAAC;AACzB;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,OAAO,WAAW,CAAC,OAAO,YAAY;AACtC,gBAAI,SAAS,IAAI;AACjB,mBAAO,KAAK,MAAM,OAAO,MAAM,KAAK;AAChC,kBAAI,OAAO,OAAO,GAAG;AACrB,kBAAI,KAAK,OAAO,eAAe;AAC3B,uBAAO;AACP,oBAAI,MAAM,MAAM;AACZ,yBAAO;AACP,yBAAO,SAAS;AAAA,gBACpB,OACK;AACD,yBAAO;AAAA,gBACX;AAAA,cACJ;AAAA,YACJ;AACA,mBAAO,YAAY,MAAM,UAAU,QAAQ,IAAI,CAAC;AAAA,UACpD;AACA,cAAI,MAAM,OACN,EAAE,OAAO,WAAW,OAAO,cAAc,CAAC,OAAO,SAAS;AAC1D,mBAAO,QAAQ,EAAE;AACjB,mBAAO,mBAAmB,OAAO;AAAA,UACrC,OACK;AACD,gBAAI,CAAC,aAAa,CAAC,MAAM,CAAC,OAAO,WAAW,OAAO,aAAa;AAC5D,yBAAW,QAAQ,iCAAiC;AAAA,YACxD;AACA,gBAAI,MAAM,KAAK;AACX,qBAAO,QAAQ,EAAE;AAAA,YACrB,OACK;AACD,qBAAO,YAAY;AAAA,YACvB;AAAA,UACJ;AACA;AAAA,QACJ,KAAK,EAAE;AAEH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,mBAAO,UAAU;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,mBAAO,UAAU,MAAM;AACvB,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AAEH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AACjB,mBAAO,WAAW;AAAA,UACtB,WACS,aAAa,CAAC,GAAG;AAAA,UAE1B,WACS,QAAQ,WAAW,CAAC,GAAG;AAC5B,mBAAO,QAAQ,EAAE;AACjB,mBAAO,UAAU;AAAA,UACrB,WACS,MAAM,KAAK;AAChB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,UAAU;AAAA,UACrB,WACS,MAAM,KAAK;AAChB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,eAAe,OAAO,eAAe;AAAA,UAChD,OACK;AACD,uBAAW,QAAQ,aAAa;AAEhC,gBAAI,OAAO,mBAAmB,IAAI,OAAO,UAAU;AAC/C,kBAAI,MAAM,OAAO,WAAW,OAAO;AACnC,kBAAI,IAAI,MAAM,GAAG,EAAE,KAAK,GAAG,IAAI;AAAA,YACnC;AACA,mBAAO,YAAY,MAAM;AACzB,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,eAAK,OAAO,WAAW,GAAG,YAAY,MAAM,OAAO;AAC/C,qBAAS,QAAQ,aAAa;AAC9B,mBAAO,QAAQ,EAAE;AACjB,mBAAO,WAAW;AAClB,mBAAO,QAAQ;AAAA,UACnB,WACS,OAAO,WAAW,MAAM,MAAM;AACnC,mBAAO,QAAQ,EAAE;AACjB,mBAAO,UAAU;AACjB,mBAAO,WAAW;AAAA,UACtB,YACU,OAAO,WAAW,GAAG,YAAY,MAAM,SAAS;AACtD,mBAAO,QAAQ,EAAE;AACjB,gBAAI,OAAO,WAAW,OAAO,SAAS;AAClC,yBAAW,QAAQ,6CAA6C;AAAA,YACpE;AACA,mBAAO,UAAU;AACjB,mBAAO,WAAW;AAAA,UACtB,WACS,MAAM,KAAK;AAChB,qBAAS,QAAQ,qBAAqB,OAAO,QAAQ;AACrD,mBAAO,WAAW;AAClB,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,QAAQ,CAAC,GAAG;AACjB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,YAAY;AAAA,UACvB,OACK;AACD,mBAAO,YAAY;AAAA,UACvB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,OAAO,GAAG;AAChB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,IAAI;AAAA,UACf;AACA,iBAAO,YAAY;AACnB;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AACjB,qBAAS,QAAQ,aAAa,OAAO,OAAO;AAC5C,mBAAO,UAAU;AAAA,UACrB,OACK;AACD,mBAAO,WAAW;AAClB,gBAAI,MAAM,KAAK;AACX,qBAAO,QAAQ,EAAE;AAAA,YACrB,WACS,QAAQ,CAAC,GAAG;AACjB,qBAAO,QAAQ,EAAE;AACjB,qBAAO,IAAI;AAAA,YACf;AAAA,UACJ;AACA;AAAA,QACJ,KAAK,EAAE;AACH,iBAAO,WAAW;AAClB,cAAI,MAAM,OAAO,GAAG;AAChB,mBAAO,IAAI;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,iBAAO,WAAW;AAClB,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,QAAQ,CAAC,GAAG;AACjB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,IAAI;AAAA,UACf;AACA;AAAA,QACJ,KAAK,EAAE;AACH,iBAAO,WAAW;AAClB,cAAI,MAAM,OAAO,GAAG;AAChB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,IAAI;AAAA,UACf;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,mBAAO,WAAW;AAAA,UACtB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AACjB,mBAAO,UAAU,SAAS,OAAO,KAAK,OAAO,OAAO;AACpD,gBAAI,OAAO,SAAS;AAChB,uBAAS,QAAQ,aAAa,OAAO,OAAO;AAAA,YAChD;AACA,mBAAO,UAAU;AAAA,UACrB,OACK;AACD,mBAAO,WAAW,MAAM;AACxB,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,uBAAW,QAAQ,mBAAmB;AAGtC,mBAAO,WAAW,OAAO;AACzB,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,mBAAO,SAAS;AAAA,UACpB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,mBAAO,SAAS,MAAM;AACtB,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,gBAAI,OAAO,OAAO;AACd,uBAAS,QAAQ,WAAW,OAAO,KAAK;AAAA,YAC5C;AACA,qBAAS,QAAQ,cAAc;AAC/B,mBAAO,QAAQ;AACf,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,MAAM,KAAK;AAChB,mBAAO,SAAS;AAAA,UACpB,OACK;AACD,mBAAO,SAAS,OAAO;AACvB,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,aAAa,CAAC,GAAG;AACtB,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,mBAAO,gBAAgB;AAAA,UAC3B;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,CAAC,OAAO,gBAAgB,aAAa,CAAC,GAAG;AACzC;AAAA,UACJ,WACS,MAAM,KAAK;AAChB,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,mBAAO,gBAAgB;AAAA,UAC3B;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,qBAAS,QAAQ,2BAA2B;AAAA,cACxC,MAAM,OAAO;AAAA,cACb,MAAM,OAAO;AAAA,YACjB,CAAC;AACD,mBAAO,eAAe,OAAO,eAAe;AAC5C,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,mBAAO,gBAAgB,MAAM;AAC7B,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,QAAQ,UAAU,CAAC,GAAG;AACtB,mBAAO,WAAW;AAAA,UACtB,OACK;AACD,mBAAO,MAAM;AACb,gBAAI,MAAM,KAAK;AACX,sBAAQ,MAAM;AAAA,YAClB,WACS,MAAM,KAAK;AAChB,qBAAO,QAAQ,EAAE;AAAA,YACrB,OACK;AACD,kBAAI,CAAC,aAAa,CAAC,GAAG;AAClB,2BAAW,QAAQ,+BAA+B;AAAA,cACtD;AACA,qBAAO,QAAQ,EAAE;AAAA,YACrB;AAAA,UACJ;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,oBAAQ,QAAQ,IAAI;AACpB,qBAAS,MAAM;AAAA,UACnB,OACK;AACD,uBAAW,QAAQ,gDAAgD;AACnE,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AAEH,cAAI,aAAa,CAAC,GAAG;AACjB;AAAA,UACJ,WACS,MAAM,KAAK;AAChB,oBAAQ,MAAM;AAAA,UAClB,WACS,MAAM,KAAK;AAChB,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,QAAQ,WAAW,CAAC,GAAG;AAC5B,mBAAO,aAAa;AACpB,mBAAO,cAAc;AACrB,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,uBAAW,QAAQ,wBAAwB;AAAA,UAC/C;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,MAAM,KAAK;AAChB,uBAAW,QAAQ,yBAAyB;AAC5C,mBAAO,cAAc,OAAO;AAC5B,mBAAO,MAAM;AACb,oBAAQ,MAAM;AAAA,UAClB,WACS,aAAa,CAAC,GAAG;AACtB,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,QAAQ,UAAU,CAAC,GAAG;AAC3B,mBAAO,cAAc;AAAA,UACzB,OACK;AACD,uBAAW,QAAQ,wBAAwB;AAAA,UAC/C;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,KAAK;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,aAAa,CAAC,GAAG;AACtB;AAAA,UACJ,OACK;AACD,uBAAW,QAAQ,yBAAyB;AAC5C,mBAAO,IAAI,WAAW,OAAO,UAAU,IAAI;AAC3C,mBAAO,cAAc;AACrB,qBAAS,QAAQ,eAAe;AAAA,cAC5B,MAAM,OAAO;AAAA,cACb,OAAO;AAAA,YACX,CAAC;AACD,mBAAO,aAAa;AACpB,gBAAI,MAAM,KAAK;AACX,sBAAQ,MAAM;AAAA,YAClB,WACS,QAAQ,WAAW,CAAC,GAAG;AAC5B,qBAAO,aAAa;AACpB,qBAAO,QAAQ,EAAE;AAAA,YACrB,OACK;AACD,yBAAW,QAAQ,wBAAwB;AAC3C,qBAAO,QAAQ,EAAE;AAAA,YACrB;AAAA,UACJ;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,aAAa,CAAC,GAAG;AACjB;AAAA,UACJ,WACS,QAAQ,CAAC,GAAG;AACjB,mBAAO,IAAI;AACX,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,uBAAW,QAAQ,0BAA0B;AAC7C,mBAAO,QAAQ,EAAE;AACjB,mBAAO,cAAc;AAAA,UACzB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,MAAM,OAAO,GAAG;AAChB,gBAAI,MAAM,KAAK;AACX,qBAAO,QAAQ,EAAE;AAAA,YACrB,OACK;AACD,qBAAO,eAAe;AAAA,YAC1B;AACA;AAAA,UACJ;AACA,iBAAO,MAAM;AACb,iBAAO,IAAI;AACX,iBAAO,QAAQ,EAAE;AACjB;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,aAAa,CAAC,GAAG;AACjB,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,MAAM,KAAK;AAChB,oBAAQ,MAAM;AAAA,UAClB,WACS,MAAM,KAAK;AAChB,mBAAO,QAAQ,EAAE;AAAA,UACrB,WACS,QAAQ,WAAW,CAAC,GAAG;AAC5B,uBAAW,QAAQ,kCAAkC;AACrD,mBAAO,aAAa;AACpB,mBAAO,cAAc;AACrB,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,uBAAW,QAAQ,wBAAwB;AAAA,UAC/C;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,CAAC,YAAY,CAAC,GAAG;AACjB,gBAAI,MAAM,KAAK;AACX,qBAAO,QAAQ,EAAE;AAAA,YACrB,OACK;AACD,qBAAO,eAAe;AAAA,YAC1B;AACA;AAAA,UACJ;AACA,iBAAO,MAAM;AACb,cAAI,MAAM,KAAK;AACX,oBAAQ,MAAM;AAAA,UAClB,OACK;AACD,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,CAAC,OAAO,SAAS;AACjB,gBAAI,aAAa,CAAC,GAAG;AACjB;AAAA,YACJ,WACS,SAAS,WAAW,CAAC,GAAG;AAC7B,kBAAI,OAAO,QAAQ;AACf,uBAAO,UAAU,OAAO;AACxB,uBAAO,QAAQ,EAAE;AAAA,cACrB,OACK;AACD,2BAAW,QAAQ,iCAAiC;AAAA,cACxD;AAAA,YACJ,OACK;AACD,qBAAO,UAAU;AAAA,YACrB;AAAA,UACJ,WACS,MAAM,KAAK;AAChB,qBAAS,MAAM;AAAA,UACnB,WACS,QAAQ,UAAU,CAAC,GAAG;AAC3B,mBAAO,WAAW;AAAA,UACtB,WACS,OAAO,QAAQ;AACpB,mBAAO,UAAU,OAAO,OAAO;AAC/B,mBAAO,UAAU;AACjB,mBAAO,QAAQ,EAAE;AAAA,UACrB,OACK;AACD,gBAAI,CAAC,aAAa,CAAC,GAAG;AAClB,yBAAW,QAAQ,gCAAgC;AAAA,YACvD;AACA,mBAAO,QAAQ,EAAE;AAAA,UACrB;AACA;AAAA,QACJ,KAAK,EAAE;AACH,cAAI,aAAa,CAAC,GAAG;AACjB;AAAA,UACJ;AACA,cAAI,MAAM,KAAK;AACX,qBAAS,MAAM;AAAA,UACnB,OACK;AACD,uBAAW,QAAQ,mCAAmC;AAAA,UAC1D;AACA;AAAA,QACJ,KAAK,EAAE;AAAA,QACP,KAAK,EAAE;AAAA,QACP,KAAK,EAAE;AACH,cAAI;AACJ,cAAI;AACJ,kBAAQ,OAAO,OAAO;AAAA,YAClB,KAAK,EAAE;AACH,4BAAc,EAAE;AAChB,uBAAS;AACT;AAAA,YACJ,KAAK,EAAE;AACH,4BAAc,EAAE;AAChB,uBAAS;AACT;AAAA,YACJ,KAAK,EAAE;AACH,4BAAc,EAAE;AAChB,uBAAS;AACT;AAAA,UACR;AACA,cAAI,MAAM,KAAK;AACX,gBAAI,OAAO,IAAI,kBAAkB;AAC7B,kBAAI,eAAe,YAAY,MAAM;AACrC,qBAAO,SAAS;AAChB,qBAAO,QAAQ;AACf,qBAAO,MAAM,YAAY;AAAA,YAC7B,OACK;AACD,qBAAO,MAAM,KAAK,YAAY,MAAM;AACpC,qBAAO,SAAS;AAChB,qBAAO,QAAQ;AAAA,YACnB;AAAA,UACJ,WACS,QAAQ,OAAO,OAAO,SAAS,aAAa,aAAa,CAAC,GAAG;AAClE,mBAAO,UAAU;AAAA,UACrB,OACK;AACD,uBAAW,QAAQ,kCAAkC;AACrD,mBAAO,MAAM,KAAK,MAAM,OAAO,SAAS;AACxC,mBAAO,SAAS;AAChB,mBAAO,QAAQ;AAAA,UACnB;AACA;AAAA,QACJ,SAAoC;AAChC,gBAAM,IAAI,MAAM,QAAQ,oBAAoB,OAAO,KAAK;AAAA,QAC5D;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,OAAO,YAAY,OAAO,qBAAqB;AAC/C,wBAAkB,MAAM;AAAA,IAC5B;AACA,WAAO;AAAA,EACX;AAGA,MAAI,CAAC,OAAO,eAAe;AACvB,KAAC,WAAY;AACT,UAAI,qBAAqB,OAAO;AAChC,UAAI,QAAQ,KAAK;AACjB,UAAI,gBAAgB,WAAY;AAC5B,YAAI,WAAW;AACf,YAAI,YAAY,CAAC;AACjB,YAAI;AACJ,YAAI;AACJ,YAAI,QAAQ;AACZ,YAAI,SAAS,UAAU;AACvB,YAAI,CAAC,QAAQ;AACT,iBAAO;AAAA,QACX;AACA,YAAI,SAAS;AACb,eAAO,EAAE,QAAQ,QAAQ;AACrB,cAAI,YAAY,OAAO,UAAU,KAAK,CAAC;AACvC,cAAI,CAAC,SAAS,SAAS;AAAA,UACnB,YAAY;AAAA,UACZ,YAAY;AAAA,UACZ,MAAM,SAAS,MAAM,WACvB;AACE,kBAAM,WAAW,yBAAyB,SAAS;AAAA,UACvD;AACA,cAAI,aAAa,OAAQ;AAErB,sBAAU,KAAK,SAAS;AAAA,UAC5B,OACK;AAGD,yBAAa;AACb,6BAAiB,aAAa,MAAM;AACpC,2BAAgB,YAAY,OAAS;AACrC,sBAAU,KAAK,eAAe,YAAY;AAAA,UAC9C;AACA,cAAI,QAAQ,MAAM,UAAU,UAAU,SAAS,UAAU;AACrD,sBAAU,mBAAmB,MAAM,MAAM,SAAS;AAClD,sBAAU,SAAS;AAAA,UACvB;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AAEA,UAAI,OAAO,gBAAgB;AACvB,eAAO,eAAe,QAAQ,iBAAiB;AAAA,UAC3C,OAAO;AAAA,UACP,cAAc;AAAA,UACd,UAAU;AAAA,QACd,CAAC;AAAA,MACL,OACK;AACD,eAAO,gBAAgB;AAAA,MAC3B;AAAA,IACJ,GAAG;AAAA,EACP;AACA,SAAOF;AACX;AACA,IAAM,MAAuB,cAAc;;;AC9gDpC,IAAM,0BAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAchC,IAAM,kBAAN,cAA8B,oCAAoC;AAAA,EACrE,YAAY,QAAQ;AAChB,UAAM,MAAM;AACZ,WAAO,eAAe,MAAM,QAAQ;AAAA,MAChC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,gBAAgB;AAAA,MACxC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO,CAAC,kBAAkB,gBAAgB;AAAA,IAC9C,CAAC;AACD,WAAO,eAAe,MAAM,mBAAmB;AAAA,MAC3C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,OAAO,iCAAQ;AAAA,EACxB;AAAA,EACA,OAAO,UAAU;AACb,WAAO;AAAA,EACX;AAAA,EACA,MAAM,MAAM,MAAM;AACd,QAAI,CAAC,MAAM;AACP,aAAO;AAAA,IACX;AACA,QAAI,CAAC,MAAM;AACP,aAAO,CAAC,EAAE,IAAI,WAAW,MAAM,IAAI,OAAO,KAAK,CAAC;AAAA,IACpD;AACA,WAAO,QAAQ,MAAM,IAAI;AAAA,EAC7B;AAAA,EACA,MAAM,mBAAmB,aAAa;AAClC,WAAO,iBAAiB,YAAY,CAAC,EAAE,IAAI;AAAA,EAC/C;AAAA,EACA,MAAM,MAAM,MAAM;AACd,WAAO,iBAAiB,IAAI;AAAA,EAChC;AAAA,EACA,wBAAwB;AA1D5B;AA2DQ,UAAM,WAAW,CAAC,EAAE,KAAK,QAAQ,KAAK,KAAK,SAAS;AACpD,WAAO,WACD,wBAAwB,QAAQ,YAAU,UAAK,SAAL,mBAAW,KAAK,UAAS,EAAE,IACrE;AAAA,EACV;AACJ;AACA,IAAM,QAAQ,CAAC,SAAS,KACnB,MAAM,IAAI,EACV,IAAI,CAAC,SAAS,KAAK,QAAQ,QAAQ,EAAE,CAAC,EACtC,KAAK,IAAI,EACT,KAAK;AACV,IAAM,oBAAoB,CAAC,UAAU;AACjC,MAAI,OAAO,KAAK,KAAK,EAAE,WAAW,GAAG;AACjC,WAAO,CAAC;AAAA,EACZ;AACA,QAAM,SAAS,CAAC;AAChB,MAAI,MAAM,SAAS,SAAS,GAAG;AAC3B,WAAO,MAAM,IAAI,IAAI,MAAM,SAAS,IAAI,iBAAiB;AACzD,WAAO;AAAA,EACX,OACK;AACD,WAAO,MAAM,IAAI,IAAI,MAAM,QAAQ;AACnC,WAAO;AAAA,EACX;AACJ;AACO,SAAS,iBAAiB,GAAG;AAChC,QAAM,gBAAgB,MAAM,CAAC;AAC7B,QAAM,SAAS,IAAI,OAAO,IAAI;AAC9B,MAAI,eAAe,CAAC;AACpB,QAAM,eAAe,CAAC;AAEtB,SAAO,YAAY,CAAC,SAAS;AACzB,UAAM,UAAU;AAAA,MACZ,MAAM,KAAK;AAAA,MACX,YAAY,KAAK;AAAA,MACjB,UAAU,CAAC;AAAA,MACX,MAAM;AAAA,MACN,eAAe,KAAK;AAAA,IACxB;AACA,QAAI,aAAa,SAAS,GAAG;AACzB,YAAM,gBAAgB,aAAa,aAAa,SAAS,CAAC;AAC1D,oBAAc,SAAS,KAAK,OAAO;AAAA,IACvC,OACK;AACD,qBAAe;AAAA,IACnB;AACA,QAAI,CAAC,KAAK,eAAe;AACrB,mBAAa,KAAK,OAAO;AAAA,IAC7B;AAAA,EACJ;AACA,SAAO,aAAa,MAAM;AACtB,QAAI,aAAa,SAAS,GAAG;AACzB,YAAM,cAAc,aAAa,IAAI;AACrC,UAAI,aAAa,WAAW,KAAK,aAAa;AAC1C,uBAAe;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO,SAAS,CAAC,SAAS;AACtB,QAAI,aAAa,SAAS,GAAG;AACzB,YAAM,iBAAiB,aAAa,aAAa,SAAS,CAAC;AAC3D,qBAAe,QAAQ;AAAA,IAC3B;AAAA,EACJ;AAEA,SAAO,cAAc,CAAC,SAAS;AAC3B,QAAI,aAAa,SAAS,GAAG;AACzB,YAAM,iBAAiB,aAAa,aAAa,SAAS,CAAC;AAC3D,qBAAe,WAAW,KAAK,IAAI,IAAI,KAAK;AAAA,IAChD;AAAA,EACJ;AAEA,QAAM,QAAQ,oBAAoB,KAAK,aAAa;AACpD,QAAM,YAAY,QAAQ,MAAM,CAAC,IAAI;AACrC,SAAO,MAAM,SAAS,EAAE,MAAM;AAE9B,MAAI,gBAAgB,aAAa,SAAS,QAAQ;AAC9C,mBAAe,aAAa,SAAS,CAAC;AAAA,EAC1C;AACA,SAAO,kBAAkB,YAAY;AACzC;",
  "names": ["input", "sax", "regex", "s", "uri"]
}
