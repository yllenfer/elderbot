{
  "version": 3,
  "sources": ["../../@langchain/core/dist/runnables/passthrough.js", "../../@langchain/core/dist/runnables/router.js", "../../@langchain/core/dist/runnables/branch.js", "../../@langchain/core/dist/runnables/history.js"],
  "sourcesContent": ["import { concat } from \"../utils/stream.js\";\nimport { Runnable, RunnableAssign, RunnableMap, } from \"./base.js\";\nimport { ensureConfig } from \"./config.js\";\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\nexport class RunnablePassthrough extends Runnable {\n    static lc_name() {\n        return \"RunnablePassthrough\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (fields) {\n            this.func = fields.func;\n        }\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        if (this.func) {\n            await this.func(input, config);\n        }\n        return this._callWithConfig((input) => Promise.resolve(input), input, config);\n    }\n    async *transform(generator, options) {\n        const config = ensureConfig(options);\n        let finalOutput;\n        let finalOutputSupported = true;\n        for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config)) {\n            yield chunk;\n            if (finalOutputSupported) {\n                if (finalOutput === undefined) {\n                    finalOutput = chunk;\n                }\n                else {\n                    try {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        finalOutput = concat(finalOutput, chunk);\n                    }\n                    catch {\n                        finalOutput = undefined;\n                        finalOutputSupported = false;\n                    }\n                }\n            }\n        }\n        if (this.func && finalOutput !== undefined) {\n            await this.func(finalOutput, config);\n        }\n    }\n    /**\n     * A runnable that assigns key-value pairs to the input.\n     *\n     * The example below shows how you could use it with an inline function.\n     *\n     * @example\n     * ```typescript\n     * const prompt =\n     *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n     * Question: {question}\n     * SQL Query:`);\n     *\n     * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n     * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n     * // In this case, we're passing the schema.\n     * const sqlQueryGeneratorChain = RunnableSequence.from([\n     *   RunnablePassthrough.assign({\n     *     schema: async () => db.getTableInfo(),\n     *   }),\n     *   prompt,\n     *   new ChatOpenAI({}).bind({ stop: [\"\\nSQLResult:\"] }),\n     *   new StringOutputParser(),\n     * ]);\n     * const result = await sqlQueryGeneratorChain.invoke({\n     *   question: \"How many employees are there?\",\n     * });\n     * ```\n     */\n    static assign(mapping) {\n        return new RunnableAssign(new RunnableMap({ steps: mapping }));\n    }\n}\n", "import { Runnable } from \"./base.js\";\nimport { ensureConfig } from \"./config.js\";\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n */\nexport class RouterRunnable extends Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, ensureConfig(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\n", "import { Runnable, _coerceToDict, _coerceToRunnable, } from \"./base.js\";\nimport { getCallbackManagerForConfig, patchConfig, } from \"./config.js\";\nimport { concat } from \"../utils/stream.js\";\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch extends Runnable {\n    static lc_name() {\n        return \"RunnableBranch\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"default\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.branches = fields.branches;\n        this.default = fields.default;\n    }\n    /**\n     * Convenience method for instantiating a RunnableBranch from\n     * RunnableLikes (objects, functions, or Runnables).\n     *\n     * Each item in the input except for the last one should be a\n     * tuple with two items. The first is a \"condition\" RunnableLike that\n     * returns \"true\" if the second RunnableLike in the tuple should run.\n     *\n     * The final item in the input should be a RunnableLike that acts as a\n     * default branch if no other branches match.\n     *\n     * @example\n     * ```ts\n     * import { RunnableBranch } from \"@langchain/core/runnables\";\n     *\n     * const branch = RunnableBranch.from([\n     *   [(x: number) => x > 0, (x: number) => x + 1],\n     *   [(x: number) => x < 0, (x: number) => x - 1],\n     *   (x: number) => x\n     * ]);\n     * ```\n     * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n     *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n     * @returns A new RunnableBranch.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from(branches) {\n        if (branches.length < 1) {\n            throw new Error(\"RunnableBranch requires at least one branch\");\n        }\n        const branchLikes = branches.slice(0, -1);\n        const coercedBranches = branchLikes.map(([condition, runnable]) => [\n            _coerceToRunnable(condition),\n            _coerceToRunnable(runnable),\n        ]);\n        const defaultBranch = _coerceToRunnable(branches[branches.length - 1]);\n        return new this({\n            branches: coercedBranches,\n            default: defaultBranch,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        let result;\n        for (let i = 0; i < this.branches.length; i += 1) {\n            const [condition, branchRunnable] = this.branches[i];\n            const conditionValue = await condition.invoke(input, patchConfig(config, {\n                callbacks: runManager?.getChild(`condition:${i + 1}`),\n            }));\n            if (conditionValue) {\n                result = await branchRunnable.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`branch:${i + 1}`),\n                }));\n                break;\n            }\n        }\n        if (!result) {\n            result = await this.default.invoke(input, patchConfig(config, {\n                callbacks: runManager?.getChild(\"branch:default\"),\n            }));\n        }\n        return result;\n    }\n    async invoke(input, config = {}) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async *_streamIterator(input, config) {\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, config?.runName);\n        let finalOutput;\n        let finalOutputSupported = true;\n        let stream;\n        try {\n            for (let i = 0; i < this.branches.length; i += 1) {\n                const [condition, branchRunnable] = this.branches[i];\n                const conditionValue = await condition.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`condition:${i + 1}`),\n                }));\n                if (conditionValue) {\n                    stream = await branchRunnable.stream(input, patchConfig(config, {\n                        callbacks: runManager?.getChild(`branch:${i + 1}`),\n                    }));\n                    for await (const chunk of stream) {\n                        yield chunk;\n                        if (finalOutputSupported) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                try {\n                                    finalOutput = concat(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = undefined;\n                                    finalOutputSupported = false;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (stream === undefined) {\n                stream = await this.default.stream(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(\"branch:default\"),\n                }));\n                for await (const chunk of stream) {\n                    yield chunk;\n                    if (finalOutputSupported) {\n                        if (finalOutput === undefined) {\n                            finalOutput = chunk;\n                        }\n                        else {\n                            try {\n                                finalOutput = concat(finalOutput, chunk);\n                            }\n                            catch (e) {\n                                finalOutput = undefined;\n                                finalOutputSupported = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n}\n", "import { AIMessage, HumanMessage, isBaseMessage, } from \"../messages/index.js\";\nimport { RunnableBinding, RunnableLambda, } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory extends RunnableBinding {\n    constructor(fields) {\n        let historyChain = new RunnableLambda({\n            func: (input, options) => this._enterHistory(input, options ?? {}),\n        }).withConfig({ runName: \"loadHistory\" });\n        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n        if (messagesKey) {\n            historyChain = RunnablePassthrough.assign({\n                [messagesKey]: historyChain,\n            }).withConfig({ runName: \"insertHistory\" });\n        }\n        const bound = historyChain\n            .pipe(fields.runnable.withListeners({\n            onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        }))\n            .withConfig({ runName: \"RunnableWithMessageHistory\" });\n        const config = fields.config ?? {};\n        super({\n            ...fields,\n            config,\n            bound,\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"historyMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getMessageHistory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.getMessageHistory = fields.getMessageHistory;\n        this.inputMessagesKey = fields.inputMessagesKey;\n        this.outputMessagesKey = fields.outputMessagesKey;\n        this.historyMessagesKey = fields.historyMessagesKey;\n    }\n    _getInputMessages(inputValue) {\n        if (typeof inputValue === \"string\") {\n            return [new HumanMessage(inputValue)];\n        }\n        else if (Array.isArray(inputValue)) {\n            return inputValue;\n        }\n        else {\n            return [inputValue];\n        }\n    }\n    _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue) {\n        let newOutputValue = outputValue;\n        if (!Array.isArray(outputValue) &&\n            !isBaseMessage(outputValue) &&\n            typeof outputValue !== \"string\") {\n            newOutputValue = outputValue[this.outputMessagesKey ?? \"output\"];\n        }\n        if (typeof newOutputValue === \"string\") {\n            return [new AIMessage(newOutputValue)];\n        }\n        else if (Array.isArray(newOutputValue)) {\n            return newOutputValue;\n        }\n        else if (isBaseMessage(newOutputValue)) {\n            return [newOutputValue];\n        }\n        throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(newOutputValue, null, 2)}`);\n    }\n    async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, kwargs) {\n        const history = kwargs?.config?.configurable?.messageHistory;\n        if (this.historyMessagesKey) {\n            return history.getMessages();\n        }\n        const inputVal = input ||\n            (this.inputMessagesKey ? input[this.inputMessagesKey] : undefined);\n        const historyMessages = history ? await history.getMessages() : [];\n        const returnType = [\n            ...historyMessages,\n            ...this._getInputMessages(inputVal),\n        ];\n        return returnType;\n    }\n    async _exitHistory(run, config) {\n        const history = config.configurable?.messageHistory;\n        // Get input messages\n        const { inputs } = run;\n        const inputValue = inputs[this.inputMessagesKey ?? \"input\"];\n        const inputMessages = this._getInputMessages(inputValue);\n        // Get output messages\n        const outputValue = run.outputs;\n        if (!outputValue) {\n            throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n        }\n        const outputMessages = this._getOutputMessages(outputValue);\n        for await (const message of [...inputMessages, ...outputMessages]) {\n            await history.addMessage(message);\n        }\n    }\n    async _mergeConfig(...configs) {\n        const config = await super._mergeConfig(...configs);\n        // Extract sessionId\n        if (!config.configurable || !config.configurable.sessionId) {\n            const exampleInput = {\n                [this.inputMessagesKey ?? \"input\"]: \"foo\",\n            };\n            const exampleConfig = { configurable: { sessionId: \"123\" } };\n            throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n        }\n        // attach messageHistory\n        const { sessionId } = config.configurable;\n        config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n        return config;\n    }\n}\n"],
  "mappings": "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",
  "names": ["input", "i", "config"]
}
